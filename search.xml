<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里巴巴国际无线技术部 - 在这里遇见最好的自己]]></title>
    <url>%2F2018%2F01%2F12%2FJobs%2F</url>
    <content type="text"><![CDATA[我们做什么阿里巴巴国际无线技术部背靠阿里巴巴集团和阿里巴巴国际站，阿里巴巴国际站是全球领先的跨境B2B一站式交易服务数据平台，服务全世界数以千万计的采购商和供应商，阿里巴巴国际站（www.alibaba.com）帮助中小企业拓展国际贸易的出口营销推广服务，专注服务于全球中小微企业，在平台上，通过向海外买家展示、推广供应商的企业和产品，进而获得贸易商机和订单，买卖双方可以在线更高效地找到适合的彼此，并更快更安心地达成交易，是出口企业拓展国际贸易的首选跨境贸易平台。 阿里巴巴国际站技术致力于打造一站式eWTP全球国际B类贸易服务平台解决方案，基于大数据在搜索、推荐、营销、流量、金融等场景中提供全方位一站式的服务。 近年来，随着智能手机的普及无线的趋势已经锐不可当。阿里巴巴国际无线技术部不仅是站在阿里巴巴集团和阿里巴巴国际站两个巨人的肩上，更是站在无线时代的浪潮之上。来吧少年，一起为全球中小企业服务！ 我们在哪里杭州 - 一座来了就不想走的城市杭州有“欲把西湖比西子，淡妆浓抹总相宜”的西湖， 杭州有“钱塘岸上春如织，淼淼寒潮带晴色”的钱塘江（潮）， 杭州有“最爱湖东行不足，绿杨阴里白沙堤”的白堤，。。。。。。从古至今无数的文人墨客为杭州驻足，给杭州添色。正所谓“你在杭州看风景,看风景的人在历史中看你”。古有一本《西湖梦寻》让无数人慕名杭州，今有一家“阿里巴巴”让追梦人逐梦杭州。来吧少年，“江南无所有，聊赠一聘书”。 为什么是我们阿里巴巴早已经是一家庞大的集团公司，有大家熟知的淘宝、天猫等等。然而我却要说请记住它们，但请来阿里巴巴国际无线技术部： 内部环境：国际化 - 集团三大战略之一早在2015年阿里巴巴集团提出：农村化、国际化、大数据和云计算是阿里巴巴集团未来的三大战略，2016年马老师又创造性的提出了eWTP，2016年9月马老师在二十国集团工商峰会（B20）发表演讲，系统性的阐述eWTP的理念、愿景和行动计划。并且在一年中几乎飞遍全球，向各国政府、国际组织描述和倡议eWTP。 2017年6月阿里巴巴在美国底特律举办大规模的论坛，马老师做了“中国的贸易机会”的主题演讲，更是承诺未来的5年内在美国创造100万的工作机。无论是国际化、eWTP和中美贸易阿里巴巴国际无线技术部都是最重要的战场。 外部环境：一带一路 - 国家级顶层战略2013年，中国首次超越美国跃居世界第一大贸易国。持续三年世界第一之后，世贸组织（WTO）的最新数据显示，2016年中国的进出口贸易额被美国反超，丧失了“世界第一外贸国家”的称号。 2015国家发展改革委、外交部、商务部联合发布了《推动共建丝绸之路经济带和21世纪海上丝绸之路的愿景与行动》，即是大家熟知的“一带一路”。它将充分依靠中国与有关国家既有的双多边机制，借助既有的、行之有效的区域合作平台，一带一路旨在借用古代丝绸之路的历史符号，高举和平发展的旗帜，积极发展与沿线国家的经济合作伙伴关系，共同打造政治互信、经济融合、文化包容的利益共同体、命运共同体和责任共同体。可以说“一带一路”和eWTP有异曲同工之秒。 2017年3月16号《中国新外贸模式研究报告》正式发布，重点分析了以阿里巴巴为代表的新外贸模式。结论是：新外贸模式极大降低了中国外贸的交易成本，同时交易平台提供的信息、数据和生态价值，会随时间增加为企业带来更大价值。阿里巴巴提倡的新外贸模式是外贸行业的新拐点。 无论是内部环境还是外部环境，作为阿里巴巴发家的阿里巴巴国际站正站在新的历史起点欲展翅翱翔，来吧少年，一起鹰击长空。 我们的技术在新技术上无论是Andriod还是iOS，我们积极跟进业内新技术，试验落地。比如：在Apple Watch产品发布之初便做了适配、遵循Andriod的MD规范、DeepLink、Firebase等；在国际化上自研多语言的实时更新引擎、RTL适配，做到覆盖全球所有主流语种、货币单位等。 阿里巴巴国际无线技术部出品的Alibaba.com Andriod APP 多次获得Google Play官方推荐，以2017年3月10日为例：我们获得Google Play 104个国家的主页和购物分类的黄金展位。这是我们不断追求卓越，不断提升用户体验，不断创新的结果。由于我们在技术上的精益求精，我们始终和Google保持着非常良好的合作关系。更多的荣誉： 来吧少年，一起码出未来！ 我们的团队阿里巴巴国际无线技术部现聚集40多名江湖三大名门正派（Andriod, iOS,JAVA）的顶级高手，由江湖人称“小马哥”的带头大哥领导，在这里每一个人都身怀绝技，一起来走进这些可爱的小伙伴吧： 如果你是终生学习者，如果你对认知科学、商业本质感兴趣，来吧少年！“小马哥”之所以称为“小马哥”，不仅仅因为他姓马，也不仅仅他的英文名叫“Jack”，更重要的是有马老师的风采。如果你常年关注“得到APP”，你一定对傅盛、刘润、罗胖、李笑来等等如数家珍，那么来吧少年，在这里近距离感受“小马哥”价值2W的《认知升级》。在这里每一天都是成长！如果你是iOS的开发者，又常见混迹开源社区，来吧少年！曾宪华：Github账号xhzengAIB，Objective-C社区世界排名15，中国排名第6。来吧少年！和大神面对面。 更多大神的资料请看：http://zengxianhua.comhttp://tutuge.mehttp://www.tanhao.mehttps://github.com/zekunyanhttps://github.com/caoping 如果你怀有一颗不安分的心，来吧少年！我们一起去探索这个世界： 如果你精通八大菜系，来吧少年！我们一起去吃遍全球：如果以上这些都还不够打动你，那么下面一张一定可以： 转自阿里巴巴国际无线技术部 - 在这里遇见最好的自己招聘启事长期有效，欢迎投递。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京，撤了]]></title>
    <url>%2F2017%2F09%2F02%2Fabout-to-leave%2F</url>
    <content type="text"><![CDATA[呵呵，撤了。 前阵子看王垠最新的文章关于离开北京的决定，一度让我觉得他来的是假的北京，或许是来的时间太久，很多事都习以为常。其实去年就萌生了离开北京的想法，那时面蚂蚁金服跪了之后觉得反正又不赶时间，还可以再等等，终究离开一个熟悉的环境开始新的工作生活还得有个好理由。年后又随着“逃离”和三五好友的离开，越发觉得继续留在北京算不上是个聪明的选择，当然我也算不上“逃离”，毕竟某种程度上算是一人吃饱全家不饿，所以可能更多的还是大射手仗剑走天涯的情愫多些。再就是终于不用再被“假装生活”了，呵呵。 北京不好么？虽然一些政策真的不再像08年那么的欢迎你，但北京依旧是中国互联网行业发展最好的城市，这点是碾压其他城市的。相比其他城市的寡头垄断，这里多元化的产业、众多的天使、VC，一票大公司、小公司、草根创业，都提供着无数的机(zheng)会(qian)，这些优势应该会持续相当长的时间。这里是梦想野蛮生长的伟大而邪恶的容器，当然这话也不是我说的，是吴晓波说的。抛开梦想不谈，毕竟这东西没实现前跟狗屎也没两样，所以藏着就好。但是另外一个角度说下容器我是认同的，要不去感受下早高峰的西二旗、回龙观、四惠八通线等。虽然从15年开始我基本都靠走路上下班，但是偶尔天冷打车绝大多时候都是堵成狗。另外对于高房价、户籍制度估计很多人都会有一句“自由、富强、民主、平等”可以讲一讲。当然如果真要算上雾霾，这其实是许多内陆城市都面临的问题，但显然北京动则就爆表还是来得更恐怖些。但是如果不考虑这些方面北京真的算是非常具有活力的城市了，仍旧有非常多非常多吸引年轻人的地方，譬如吃。 关于收获。一直都觉得在北京这五年来走的还算顺利，一路遇到了好的领导，靠谱的同事。头、肖哥、蒲、段哥、远鹏，当然还有毛波儿，虽然在博纳的时候没少喷我。这些可能是我在这几年攒了点儿写码的技能外最大的收获了。头在北京几套房开着“把妹王”，还有三个漂亮的小情人，简直人生赢家。蒲临走的时候还在推荐机会，电话打得超过1个多小时，当面从10点多聊到了12点半，搞得午饭都没吃，虽然最后也没说服我，估计那时身边有刀的话捅死我的心都有了。其实每个阶段有人能告诉你下一步该怎么走真得是件非常幸运的事，但自己蒙错了磕破点皮也未见得是件坏事，当然后者可能需要你还年轻可以试错。另外人生的高度很大一部分取决于你周边的几个人，没准哪天谁拿着账上的一千万说我们就差个程序员了，所以在这之前能做的就是不坑队友，或者是让他们相信你不会坑队友。就像打“亡者农药”一样，钻石的朋友多了你上钻石的概率也会大些，但那为啥我现在还是个铂金？ 还会回北京么，没准杀红了眼还真可能会折回北京；也可能干了这票就回老家摆水果摊；也有可能选个沿海城市养条狗，没事去海边喂喂海鸥，因为这感觉太特么爽了。 后面的事，谁说得准呢。]]></content>
      <tags>
        <tag>生活</tag>
        <tag>呵呵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Objective-C：Category 的一点理解]]></title>
    <url>%2F2017%2F02%2F18%2FStudyCategory%2F</url>
    <content type="text"><![CDATA[category 是 OC 2.0后添加的新特性，主要作用是给已经存在的类添加方法，当然秉着类的单一职责原则和接口隔离原则我们通常会将不同功能的类扩展分别写在不同的文件中，这样不仅减少了单个文件的体积，同时可以对 category 进行按需加载。 category 的定义所有的 OC 类和对象在 runtime 层其实都是 strcut，比如 objc_class、objc_object， 甚至 block(__block_impl) 还定义有自己的 isa 指针，category 也是如此。 12345678typedef struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties;&#125; category_t; 定义中包含了： 类的名字（name） 类（cls） category中所有给类添加的实例方法的列表（instanceMethods） category中所有添加的类方法的列表（classMethods） category实现的所有协议的列表（protocols） category中添加的所有属性（instanceProperties） 这里我们着重关心一下 instanceMethods，因为 category 中给类添加的实例方法最终就会放在这个列表中，如果有你多个 category，那么在程序加载前会将所有的实例方法列表遍历组装成一个大的实例方法列表，最终会添加到 objc_class 的 methodLists 中，而 category 中的方法会在新的方法列表前面，所以当我们给一个对象发送消息时，会优先查找到 category 中的方法，当然在这之前会优先查找一下方法缓存 objc_cache。 category 中的”覆盖”如果 category 定义跟系统类方法重名会出现什么情况呢？这里我们给 NSString 扩展添加一个系统同名的方法 1- (unichar)characterAtIndex:(NSUInteger)index; 首先如果我们真的这么做的话，编译器直接就会报警告:Category is implementing a method which will also be implemented by its primary class. If the name of a method declared in a category is the same as a method in the original class, or amethod in another category on the same class (or even a superclass), the behavior is undefined as towhich method implementation is used at runtime. 这是苹果 Category Method Name Clashes 中间一段的解释，所以我们在给标准的 Cocoa 类添加重名类方法在运行时可能会出现问题。 如果我们忽略这个警告，代码是可以正常编译且运行的，而且通过 class_copyMethodList 获取列表后然后遍历所有的方法： 12345678unsigned int methodCount;Method *methodList = class_copyMethodList([NSString class], &amp;methodCount);for (NSInteger i = 0; i &lt; methodCount; i++)&#123; Method method = methodList[i]; NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding]; NSLog(@"methodName = %@", methodName);&#125; 会发现列表中存在两个 characterAtIndex 方法，这里如果我们进一步通过遍历调用 characterAtIndex 方法的话，结果两次执行的都是系统类方法的实现，而我们自己 category 中的方法是无法被执行的，也就是说如果我们 category 中的方法跟系统的方法重名的话，那么方法在 class_copyMethodList 中会存在两份，但调用仍旧执行系统的定义的。 如果 category 方法名跟系统类扩展方法重名会是一样的结论么？这里测试发现，同样运行时会有两个同名方法，但是如果调用的话会执行我们定义的，当然具体调用谁取决于 category 编译时的先后顺序，如果我们编写了多个类扩展，则可以在 Compile Sources 中进行修改。 当然前面也说了标准的 Cocoa 类是这样，如果是自定义类的类方法和类扩展方法重名的话，调用执行的话依旧是扩展中的方法，这跟在 class_copyMethodList 方法列表查找的顺序也是一致的。 category 的一些姿势替代继承继承很大的一个缺点就是打破了类的封装，基类完全向子类暴露了实现细节。且继承是一种高耦合的设计，违背了面向对象的设计原则。将类的实现分散到便于管理的数个分类之中，这样既便于管理，还可以隐藏实现细节。另外这样也更便于调试，因为分类中的方法有自己的 symbol name，当抛出错误时，可以快速根据提示进行查找。 hook 原方法我们可以在类加载 load 的时候进行 hook。典型的比如页面无埋点统计，我们只需要替换到系统控制器的几个生命周期函数既可以。或者还可以做的更多，比如数组越界防崩溃，KVO 成对的添加和移除监听，因为多线程下的重复添加或移除将直接导致应用 crash。 添加关联属性属性是数据封装的一种方式，但是在分类中是无法合成实例变量的，当然有源码的 extension 可以添加属性且自动生成对应的实例变量。分类中添加属性编译期既会抛出警告，当然可以通过 @dynamic 暂时让编译器忽略，在运行时通过消息转发机制拦截此方法那么或许可以采取这种做法。比如一个只读属性，只实现它的get方法是完全没有问题的。 关联对象可以解决分类中无法合成实例变量的问题，当然这里需要特别注意内存管理。另外一点我们还可以通过一些特殊的姿势给关联属性添加 weak 对象，这可能需要一点小技巧，虽然 objc_AssociationPolicy 并没有提供 weak 内存管理方式。比如关联 block，在 block 中引用 weak 对象。当然通过这种方式，我们还可以实现数组及字典中“弱引用”别的元素。 123456789-(void)setCurrentController:(UIViewController *)currentController&#123; objc_setAssociatedObject(self, @selector(currentController), currentController, OBJC_ASSOCIATION_RETAIN);&#125;-(UIViewController *)currentController&#123; return objc_getAssociatedObject(self, _cmd);&#125; private 分类一些经常使用的 API 可能非常适合在程序库内使用，但是又不便于暴露给外部，创建 private 分类的头文件不一起对外公开，这样就可以实现私有方法。当然通过 linkmap 我们还是可以查看到所有的第三方库定义的所有方法。 静态库中的 category由于 Objective-C 并不为每个函数定义 linker symbol，它只为每个类生成 linker symbol，也就是说类被编译链接后，类扩展将不会被链接，那么在运行时调用扩展的方法会抛出异常 exception “selector not recognized”，所以在编译时还需要 Other linker flags 下设置参数 -all_load / -force_load。 相关资料： https://tech.meituan.com/DiveIntoCategory.html http://blog.csdn.net/wlq861025/article/details/51888782]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 iOS9 下 ATS 访问本地网络]]></title>
    <url>%2F2017%2F01%2F03%2F%E5%85%B3%E4%BA%8EiOS9%E4%B8%8BATS%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[这段时间可能所有的开发 iOS 的公司都在做应用的 HTTPS 适配，因为在 WWDC 16 中，Apple 表示从 2017 年 1 月 1 日起，所有的新提交 app 默认是不允许使用 NSAllowsArbitraryLoads 来绕过 ATS 限制的，也就是说，我们最好保证 app 的所有网络请求都是 HTTPS 加密的，否则可能会在应用审核时遇到麻烦。 由于 Apple 在这之前预留了足够的时间让我们来进行网络适配，所以在这之前我们大部分情况下将 NSAllowsArbitraryLoads 设置为 YES，这样网络请求不受 ATS 的限制了。 ATS属性配置当然 ATS 相关 NSAppTransportSecurity 下的诸多属性都是可选的，毕竟通常我们并不能保证我们跳转的web页面、多媒体资源、一些第三方的 SDK 等是一定支持 HTTPS 的，所以在这方面 Apple 给予了足够的可配置选项，当然在提交审核时我们需要提供一个”合理的解释”。 例如: NSAllowsArbitraryLoadsForMedia，默认值为NO，置为 YES 后，使用 AV Foundation 框架载入资源时不受 ATS 的限制；（iOS 10.0及以上支持，测试发现真机可行，模拟器未起作用） NSAllowsArbitraryLoadsInWebContent，默认值为 NO，置为 YES 后，使用 web view 的网络请求不受 ATS 限制；（iOS 10.0及以上支持） NSAllowsLocalNetworking，默认值为 NO，置为 YES 后，本地网络请求不受 ATS 限制；（iOS 10.0及以上支持） 所以我们发现这些字段都是 iOS10 下新添加的，这样就会引发我们应用在 iOS9 下可能访问 HTTP 资源失败。。。。这篇文章也并不是告诉我们怎么来升级应用的 HTTPS 的，关于 AFNetWorking 升级 HTTPS 二次验证证书的资源也有很多，这里主要记录我所在 iOS9 下所踩得坑，当然在写这篇博客的时候，Apple 也将 ATS 无限期延期了。 iOS9下访问本地网络 192.168.1.1我们的项目是需要访问本地网络的，APP 运行时连接硬件产品发出的热点，而连接采用的是 IP 地址访问，测试的时候发现 iOS10 下无论开启/关闭 ATS，IP下的网络都能正常访问，而在 iOS9 下无论怎么配置 NSAppTransportSecurity 的相关参数都无法建立网络连接，当然我们尝试了设置 NSExceptionDomains 进行设置但是并没有效果，后来觉得既然是过滤域名显然对 IP 是无效的，而不同的是 Apple 在 iOS10 下直接让 IP 连接绕过了 ATS。 其实从某种侧面考虑，仅仅是涉及到局域网内的访问貌似也不会设计到数据安全问题，所以个人猜测 iOS9 下可能是 Apple 一开始推出 ATS 而没有全面考虑而导致本地网络无法访问的。当然也发现有更多的人受到同样问题的困扰，苹果的官方解释貌似还是需要使用 NSAllowsArbitraryLoads。。。 ATS支持诊断工具服务端HTTPS适配完成后，可以先使用/usr/bin/nscurl（OS X v10.11及以上系统支持）工具模拟进行ATS网络连接状况诊断，命令如下： 1/usr/bin/nscurl --ats-diagnostics [--verbose] URL 例如 /usr/bin/nscurl –ats-diagnostics –verbose https://binhandev.github.io ats-diagnostics 参数的设定，会模拟ATS属性的不同配置场景（NSAllowsArbitraryLoads、NSExceptionMinimumTLSVersion、NSExceptionRequiresForwardSecrecy 和 NSExceptionAllowsInsecureHTTPLoads 的不同组合）进行连接； verbose 指定时，可显示ATS不同配置场景的详细信息。 相关资料： https://yq.aliyun.com/articles/62563 http://stackoverflow.com/questions/30903923/app-transport-security-and-ip-addresses-in-ios9 https://forums.developer.apple.com/thread/6205]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/UDP 通讯下包与流]]></title>
    <url>%2F2016%2F09%2F18%2FTCP%3AUDP%20%E9%80%9A%E8%AE%AF%E4%B8%8B%E5%8C%85%E4%B8%8E%E6%B5%81%2F</url>
    <content type="text"><![CDATA[关于 TCP 流与包的概念首先需要明确一个概念，TCP 是以二进制流式传送数据的，既发送端与接收端成功建立连接下即可以不停的发送数据包，不同数据包间并没有明确的边界定义；而 UDP 发送数据的时候是按照一个一个的数据包去发送的。所以 TCP 发送数据是一个二进制流，而管道内的数据是一个个封装好的数据包。另外很重要的一点是，无论是发送端发送数据，还是接收端接收数据，都存在一个数据的缓冲区，而当发送端等待缓冲区满才发送数据，就会造成缓冲区有多个数据包，数据包可能会在开启 Nagle 算法的情况下进行合并发送；而接收端不及时处理缓冲区的数据包时，既同样造成缓冲区存在多个数据包，应用层可能会一次 read 完多个数据包。所以在发送端，我们需要对数据按照事先约定好的协议进行合理的封装，在接收端，我们需要按照协议对数据进行拆分。 关于 Nagle 算法TCP 默认是会开启 Nagle 算法的，Nagle 算法主要做两件事： 只有上一个分组得到确认，才会发送下一个分组，这样的做法是为了优化网络；既当发送多个小数据包时，若上一个数据包的 ACK 返回较慢导致缓冲区数据包过多时，此算法会将多个小数据包合并为一个大包进行发送。因为在 TCP 协议下即使你发送一个字节，那么按照协议他也会被封装为一个数据包进行发送，这样额外添加 TCP header (传输层)和 IP header（网络层）信息来组装包，这样不光消耗流量，还可能造成网络拥堵。 另外接收端可能也会对 ACK 进行延迟返回，甚至可能将 ACK 添加到发送的数据包内进行返回。 这么做很重要的一个优点就是优化网络，减少小数据包的发送，但是这样一来一回都增加了延迟处理，就大大增加了网络延迟。当然发送端是可以对此算法继续关闭的，关闭方法，点这里。 对数据包进行边界划分这里相对传统的做法，即是对数据包进行划分，然后进行添加“头部描述”。 下面是 CocoaAsyncSocket UDP 下发送数据最终调用的方法，已经对参数进行注释。 1234567891011/** UDP 发送数据 @param data 数据包 @param host 接收端 host 地址 @param port 接收端 port 端口 @param timeout 超时 -1 即为不超时 @param tag 标识 */- (void)sendData:(NSData *)data toHost:(NSString *)host port:(uint16_t)port withTimeout:(NSTimeInterval)timeout tag:(long)tag 举个例子，为数据添加“头部描述”，这里的做法其实就是在每次发送数据前，添加一个描述数据大小长度的数据包，以此来告诉接收端，有一点类似 HTTP 协议中的 Request Line 头，是对数据包大小长度的描述，当然我们还可以添加别的描述，类图数据类型，如是否为文本(txt)、图片(img)、文件(file)等，本质上是一个字典。 下面是发送端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243- (void)sendMsg&#123; NSData *textData = [@"测试文本" dataUsingEncoding:NSUTF8StringEncoding]; [self sendData:data :@"txt"]; NSData *imgData = [NDData dataWithContentsOfFile:imageFile]; [self sendData: imgData :@"img"]; NSData *fileData = [NDData dataWithContentsOfFile:file]; [self sendData: fileData :@"file"];&#125;/** 发送数据 @param data 数据包 @param type 数据包类型 */- (void)sendData:(NSData *)data :(NSString *)type&#123; NSUInteger size = data.length; NSMutableDictionary *headDic = [NSMutableDictionary dictionary]; [headDic setObject:type forKey:@"type"]; [headDic setObject:[NSString stringWithFormat:@"%ld",size] forKey:@"size"]; NSString *jsonStr = [self dictionaryToJson:headDic]; NSData *lengthData = [jsonStr dataUsingEncoding:NSUTF8StringEncoding]; NSMutableData *mData = [NSMutableData dataWithData:lengthData]; //其实 [GCDAsyncSocket CRLFData] 就是一个 \r\n。我们用它来做头部的边界。 [mData appendData:[GCDAsyncSocket CRLFData]]; [mData appendData:data]; [_udpSocket sendData:data toHost:kIp port:port withTimeout:-1 tag:-1];&#125;/** 将字典转化为字符串 @param dic “头部描述”字典 @return 描述文件内容 */- (NSString *)dictionaryToJson:(NSDictionary *)dic&#123; NSError *error = nil; NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;error]; return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];&#125; 下面是接收端代码，主要思路为先将数据包的“头部描述”解析出来，然后在解析数据： 12345678910111213141516171819202122232425262728293031323334353637383940- (void)udpSocket:(GCDAsyncUdpSocket *)sock didReceiveData:(NSData *)data fromAddress:(NSData *)address withFilterContext:(nullable id)filterContext&#123; // 获取数据包“头部描述” if (!currentPacketHead) &#123; currentPacketHead = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil]; NSUInteger packetLength = [currentPacketHead[@"size"] integerValue]; [sock readDataToLength:packetLength withTimeout:-1 tag:-1]; return; &#125; if (!currentPacketHead) &#123; NSLog(@"error：当前数据包的头为空"); return; &#125; NSUInteger packetLength = [currentPacketHead[@"size"] integerValue]; //数据包出错 if (packetLength &lt;= 0 || data.length != packetLength) &#123; NSLog(@"error：当前数据包数据大小不正确"); return; &#125; NSString *type = currentPacketHead[@"type"]; if ([type isEqualToString:@"img"]) &#123; UIImage *image = [UIImage imageWithData:data]; NSLog(@"数据包为图片"); &#125; else if ([type isEqualToString:@"file"]) &#123; NSLog(@"数据包为文件"); &#125; else &#123; NSString *msg = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@"数据包为文本"); &#125; currentPacketHead = nil; 另外一种形式对数据包边界划分在某些项目中，发送端与接收端的数据包的内容可能是事先定义好协议，规定数据包某一字节为数据包长度。例如传递每一个字节都是是 byte 类型数据，我们可以对数据的某一位定义为该条数据包的长度，那么接收端在接收到数据时，先解析数据事先约定好的长度标志位，即可获取到数据包的长度，伪代码如下： 1234567uint8_t b = 0;NSMutableData *data = [[NSMutableData alloc] init];b = 0xA0; [ret appendBytes:&amp;b length:1];b = 0x04; [ret appendBytes:&amp;b length:1];b = 0xE1; [ret appendBytes:&amp;b length:1];b = 0x02; [ret appendBytes:&amp;b length:1];[_udpSocket sendData:data toHost:kIp port:port withTimeout:-1 tag:-1]; 我们可以看到发送的 data 数据数据长度是4位，这里假定事先约定长度的为第 2 个字节。 而接受端伪代码如下，用此次获取 data 数据的实际长度与约定位数长度的值进行比对，当然如果数据的长度大于约定位数的长度时，我们需要递归拆包： 1234567891011121314151617181920212223242526272829303132- (void)udpSocket:(GCDAsyncUdpSocket *)sock didReceiveData:(NSData *)data fromAddress:(NSData *)address withFilterContext:(nullable id)filterContext&#123; uint8_t *buf = (uint8_t*)[data bytes]; // 此次接收的 data 数据包大小 NSUInteger bufLen = data.length; //其中第一条数据的大小 uint8_t len = buf[1]; if (bufLen &lt; len) &#123; NSLog(@"error：当前数据包数据大小不正确"); return; &#125; [self cutData:data];&#125;- (void)cutData:(NSData *)data&#123; uint8_t *buf = (uint8_t*)[data bytes]; NSUInteger bufLen = data.length; uint8_t len = buf[1]; if (length == cmdLength) &#123; NSLog(@"数据正好完整"); &#125; else &#123; NSLog(@"数据包较大时，递归拆包获取每一个小数据包"); NSData *data = [[NSData alloc] initWithBytes: buf +cmdLength length:length-cmdLength]; [self cutData:data]; &#125;&#125; 当然对数据的封装、拆分还可以有其他的策略，比如采用特殊的字符对数据包进行分割，只要这个字符在数据包不会出现，在某些特定的场景也是可以的。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这两个月]]></title>
    <url>%2F2016%2F07%2F20%2F%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%9C%88%2F</url>
    <content type="text"><![CDATA[难得好好休息的小两个月，先与基友们相聚大连，紧接着一家人自驾跑了一趟九寨沟和四川，后独自深港行，转机跟首席去了西东马，最后去了潜水圣地 Sipadan ，圆满！ 大连 九寨沟 映秀 成都 重庆 武隆 深圳 香港 吉隆坡 &amp; 亚庇 仙本那]]></content>
      <tags>
        <tag>生活</tag>
        <tag>呵呵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa 系列(三) MVVM + RAC]]></title>
    <url>%2F2016%2F05%2F15%2FReactiveCocoa-%E7%B3%BB%E5%88%97-%E4%B8%89-MVVM-RAC%2F</url>
    <content type="text"><![CDATA[对于一个开发者来说, MVC 设计模式被广泛应用于各种语言的开发中，这在 iOS 开发中体现的尤为多，比如我们的控制器 Controller，视图 View，模型 Model，从名称中就可以体现出各自的作用及分工，Apple 也是推荐我们使用 MVC 模式进行程序设计及开发。其实绝大部分时候 MVC 模式基本是可以满足我们的业务需求的，可是随着业务的膨胀，开发人员变动等因素，MVC 模式也暴露了其弊端，当控制器层变得越来越臃肿的时候，业务过于集中到控制器层，就会为为接下来的开发带来不便及代码的可维护性变低。 所以这时候为了解决刚才的问题，MVVM 模式就“应孕而生”了，它不仅仅可以对原有 MVC 模式进行代码上的优化瘦身，更重要的一点是兼容 MVC 模式，我们可以对原有项目必要的地方进行 MVVM 模式的升级。 关于 MVVM 的理解 在理解 MVVM 前，视图 View、模型 Model 是 MVC 中已经有的概念。在大部分开发的时候，table 可以说是我们使用最多的一个视图了，它里面的一个个 cell 视图的展示都需要设置一个模型 Model，通常会让 model 会作为 cell 的一个属性而存在，所以如果我们暂时不考虑 model 是从哪里冒出来的话，就会发现 model 和 cell 其实是一一对应的，而 cell 中展示的内容全部来自于 model 对象。现在我们在来看控制器 Controller，其实每一个 Controller 都会都应一个视图 View，那么这个视图的数据来源哪里呢，没错来自 Controller 本身，这也是造成 MVC 模式臃肿的根本原因，所以能不能对这个视图 View 也对应一个唯一的 model 呢？所以就产生了 ViewModel，这也就是 MVVM 模式的基础模型。当然这里每个人的理解可能会有不同。关于 ViewModel 的作用就是拆分业务后，将逻辑代码、网络请求等集中在 ViewModel 中进行处理。而之前的 Controller 层依旧负责自己视图的创建，然后将视图对应的 ViewModel 进行 bind 就好了。 MVVM 结合 ReactiveCocoa这里又提到一个很重要的概念 bind。其实单单把业务通过 MVVM 拆分成更小更单一的模块时，那么 View 和 ViewModel 两者之间的数据的同步就可以交给函数式响应式编程框架 ReactiveCocoa，当然从某方面将，做数据的时时同步也有其他的方式，但是无论使用 delegate 或者 block，总是让我觉得写出来的代码不如通过 ReactiveCocoa bind 的方式显得优雅。因为系统中的 KVO、UIKit event、delegate、selector 等都增加了 RAC 支持，所以都不用去做很多跨函数的事，提供了一个单一的、统一的方法去处理异步的行为。 关于MVVM的优缺点：优点： 相对于 MVC 控制器层臃肿的逻辑与视图，是很难对某一块逻辑进行测试的，而剥离出来的 ViewModel 是一个独立的模块，所以对于逻辑部分可以进行单元测试。 正因为 ViewModel 的独立性，所以代码的可复用性更高，在某两个模块只要业务逻辑相同，那么完全可以粘贴过来将需要更改的接口部分进行修改，即可。这里面可以使用类模板减少重复的代码书写。 缺点： 项目中类(.h/.m)文件会增多，这样可能会让代码编译速度和程序启动速度变慢，当然这我觉得这个效率其实是可以忽略的。 从某方面讲，其实随着业务的逐渐庞大，是很难从根本上绝对避免功能上的耦合的，所以 ViewModel 的剥离的层级越多，也会相对增加项目结构的复杂度。比如一个 table 有 headerView，对应的 headerView 也会有一个 ViewModel，但是如果 headerView 的模块足够复杂的话，可能需要进一步的细分 headerView，那么就会增加更多的 ViewModel。 结合 RAC，排错困难。 最后，撸了一个 MVVM + RAC 的 demo，效果如下，通过搜索然后展示列表，当搜索结果为空时展示空数据视图。代码可以在Github中BlogDemo进行查看。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa 系列(二)特定场景 API 的使用]]></title>
    <url>%2F2016%2F05%2F03%2FReactiveCocoa-%E7%B3%BB%E5%88%97-%E4%BA%8C-%E5%B8%B8%E7%94%A8-API%2F</url>
    <content type="text"><![CDATA[整理了开发中一些特定场景下使用 RAC 的便利之处，关于一些常用的 API 的使用网上的资源还是很多的，就不做举例了。 比如登录页面当用户输入的账号、密码长度合法的情况下才可以点击登录按钮，否则按钮不可点击，这里条件比较简单，即账号密码长度都大于5，其实还可以使用一些正则匹配账号格式是否正确等。combineLatest 就是合并多个信号，且每个信号至少发送过一次 sendNext，才会触发合并信号。 123RAC(self.loginBT, enabled) = [RACSignal combineLatest:@[self.accountTF.rac_textSignal, self.passWordTF.rac_textSignal] reduce:^(NSString *usernameValid, NSString *passwordValid) &#123; return @(usernameValid.length &gt; 5 &amp;&amp; passwordValid.length &gt; 5);&#125;]; 使用 RACSubject 替代 Delegate，每调用一次 test 方法，则对应在 toVC2 方法中打印一次接受的 value 值。 这里利用的就是 RACSubject 既可以创建信号又可以发送信号的特性。 123456789101112131415161718192021222324252627282930313233343536373839@interface TestVC1 : UIViewController@end@implementation TestVC1-(void)toVC2:(UIButton *)btn&#123; TestVC2 *VC2 = [[TestVC2 alloc] init]; [VC2.subject subscribeNext:^(NSString *value) &#123; NSLog(@"value = %@", value); &#125;]; [self.navigationController pushViewController:VC2 animated:YES]&#125;@end@interface TestVC2 : UIViewController@property (nonatomic, strong) RACSubject *shareSubject;@end@implementation TestVC2-(void)test:(UIButton *)btn&#123; [self.subject sendNext(@"test")];&#125;-(RACSubject*)subject&#123; if (!_subject) &#123; _subject = [RACSubject subject]; &#125; return _subject;&#125;@end RACScheduler 计时器，这里看源码的话，可以看到最终是对 GCD 计时器的封装，当然也可以实现倒计时。 12345678910111213- (void)start&#123; __block NSUInteger timerNum = 0; self.disposable = [[RACScheduler mainThreadScheduler] after:[NSDate date] repeatingEvery:1.f withLeeway:0 schedule:^&#123; self.controlView.timerNum = timerNum; timerNum++; &#125;];&#125;-(void)stop&#123; [self.disposable dispose];&#125; 在控制器的 viewDidDisappear、dealloc 或者其他一些方法中执行某些操作。这个方法就是当监听到 self 的 viewDidDisappear 方法执行后会发送信号，然后做一些处理。某些方面讲这并不是一个好例子，这里也仅仅是对 rac_signalForSelector 使用的一个说明，就是通过此 API 可以监听某对象的在执行特定消息时可以回调给开发者。 123456-(void)addObserve&#123; [[self rac_signalForSelector:@selector(viewDidDisappear:)] subscribeNext:^(id x) &#123; [MBProgressHUD hideHUD]; &#125;]; &#125; 使用 RACCommand 执行网络请求，这里在实际开发中，需要对 response、error 进行判断。可以看到其实 RACCommand 内部封装的是一个信号，每当执行 RACCommand 时就会创建一个信号，所以一个 RACCommand 里包含了多个信号，如果想获取最新的信号，需要使用 executionSignals.switchToLatest，而执行一个 RACCommand 也很简单，调用 execute 即可，当然还可以传递参数。 1234567891011121314151617181920212223242526-(void)initialize&#123; [self.loadDataCommand.executionSignals.switchToLatest subscribeNext:^(id response) &#123; @strongify(self) NSLog(@"response = %@", response); &#125;];&#125;-(RACCommand *)loadDataCommand&#123; if (!_loadDataCommand) &#123; _loadDataCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [[BHNetReqManager sharedManager].bh_requestUrl(kNmpaiFound) startRequestWithCompleteHandler:^(NSURLSessionDataTask *task, id response, NSError *error) &#123; @strongify(self) [subscriber sendNext:response]; [subscriber sendCompleted]; &#125;]; return nil; &#125;]; &#125;]; &#125; return _loadDataCommand;&#125; 为网络失败添加重试机制，当然重试机制的使用场景还是很多的 12345678910111213141516171819202122__block int failedCount = 0;//创建信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id subscriber) &#123;if (failedCount &lt; 9) &#123; failedCount++; NSLog(@"我失败了"); //发送错误，才会要重试 [[BHNetReqManager sharedManager].bh_requestUrl(@"http://binhan1029.github.io/") startRequestWithCompleteHandler:^(id response, NSError *error) &#123; [subscriber sendError:nil]; &#125;]; &#125; else &#123; [subscriber sendNext:@"成功"]; &#125; return nil; &#125;];RACSignal *retrySignal = [signal retry];[retrySignal subscribeNext:^(id x) &#123; NSLog(@"终于成功了");&#125;]; 相关资料: http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa 系列(一) 基本概念]]></title>
    <url>%2F2016%2F04%2F26%2FReactiveCocoa-%E7%B3%BB%E5%88%97-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ReactiveCocoa 是一个 iOS 中的函数式响应式编程框架，现在已经发展到了 v4.x，开始支持 Swift 了。如果我们的项目还是 Objective-C 开发的话建议使用 v2.5，也是一个很稳定的版本。当然每当我们学习一个新的框架前，除了了解简单的 api 接口使用外，另外很重要的一点就是要思考作者所表现的编程思想。 首先 ReactiveCocoa 是一个响应式编程范式，既 FRP(Functional Reactive Programming)，简单讲在程序开发中：a ＝ b ＋ c，传统的命令式编程中赋值之后 b 或者 c 的值变化后，a 的值不会跟着变化，而在响应式编程中，a 的值会随着 b 或者 c 的值变化而变化。 另一方面 ReactiveCocoa 作者大量了使用了链式编程和函数式编程，使用过 Masonry 框架的应该都会有所体会，这样会使代码的可读性大大增强，代码更紧凑。 开发中常见的几个场景 比如我们给一个按钮添加点击事件，我们会怎么做呢？代码如下： 123456789-(void)addEvent&#123; [self.btn addTarget:self action:@selector(chick:) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)chick:(UIButton *)btn&#123; // 处理按钮的点击事件&#125; 其实这里我们可以发现一个问题，按钮的点击事件和回调函数 @selector(chick:) 已经被分离开了，既所谓的跨函数操作；另外通过 addTarget 中的 self 跟事件响应链相关联的，如果我们把 self 更改成 nil，将 chick 事件写在父控件中会发现程序仍旧能正常运行，另外一方面我们都知道方法的调用最终是给一个对象发送消息，这里我们也很难看到到底是哪个对象最终执行了回调函数 @selector(chick:)。而如果改写成 RAC 的写法理解可能就变得容易的多： 1234567-(void)addEvent&#123; [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *avatarButton) &#123; // 处理按钮的点击事件 &#125;&#125; 第二个场景，在一个 table 顶部放 banner 广告应该是一个很常见的需求，但是通常 table 列表接口与 banner 广告接口服务器端会分拆成两个不同的接口进行返回，当 banner 的广告数量为 0 时，我们需要隐藏 banner 视图。这里我们就需要对着两个接口请求做同步。当然这里比较简单粗暴的，我们可以当 banner 接口返回结果后再进行 table 列表接口，这样做当然显得不那么优雅也不建议使用。不过在 iOS 中有一个专门处理多线程执行回调同步的框架 PromiseKit。这里最后还是说下 GCD 的方式，这可能是大部分情况下采用的方式。通过 dispatch _group _t 线程同步，伪代码： 123456789101112131415161718-(void)getData&#123; // 创建 dispatch_group_t group = dispatch_group_create(); // banner 接口 dispatch_group_enter(group); [[BHNetReqManager sharedManager].bh_requestUrl(@"banner") startRequestWithCompleteHandler:^(id response, NSError *error) &#123; dispatch_group_leave(group); &#125;]; // table 接口 dispatch_group_enter(group); [[BHNetReqManager sharedManager].bh_requestUrl(@"table") startRequestWithCompleteHandler:^(id response, NSError *error) &#123; dispatch_group_leave(group); &#125;]; dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 处理数据 &#125;);&#125; 所以能看到在开发中线程同步是有很多种方式，甚至还可以使用自定义 NSOperation 通过设置依赖完成。而在 RAC 中也为我们提供了一个方式，这也是我比较推荐的，不仅仅是代码阅读起来可读性更高，另外一方面基于 RAC 开发的项目可以提供一个处理不同情况下的标准，让不同的人写出来的代码就看起来像是一个人写的一样。 123456789101112131415161718192021222324- (void)test&#123; RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id subscriber) &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; subscriber sendNext:@"A"]; &#125;); return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id subscriber) &#123; [subscriber sendNext:@"B"]; [subscriber sendNext:@"Another B"]; [subscriber sendCompleted]; return nil; &#125;]; [self rac_liftSelector:@selector(doA:withB:) withSignals:signalA, signalB, nil];// [self rac_liftSelector:@selector(doA:withB:) withSignalsFromArray:@[signalA,signalB]];&#125;- (void)doA:(NSString *)A withB:(NSString *)B&#123; NSLog(@"A:%@ and B:%@", A, B);&#125; RAC 中的一些名词概念上面只是简单举例说明 RAC 的处理一些事情的能力，当然它远远要比想象中的强大，但是在这之前我觉得还是很有必要了解一些 RAC 中涉及到的一些概念，既 RAC 中的四大核心组件。 信号源：RACStream 及其子类 翻阅的大部分的资料都会翻译成信号，其实这里如果直接理解成信号，会相当难理解出本意，所以我一般将其理解为电流。就像家里的墙上的插座一样，我们可以为在上面直接插上某件电器的插头，亦或者在外接一个插排，其实电流这玩意我们看不见摸不着，但是当你外接一个新插排，不关闭“开关”的情况下，新插排就直接可以使用了，甚至我们可以将两项/三项的插座转换为 USB 的插口供手机充电器使用。其实这个例子我觉得至少已经包含了，后面要提及到“信号的转换”和“订阅者”概念，是的每一个外接的新插排就是一个订阅者。 RACStream 是一个抽象类，开发中我们通常使用的是 RACSignal 和 RACSequence。 RACSignal 就是我们上面例子中插排电线中的电流，也就是开发中我们的数据的值。它可以向订阅者发送三种不同类型的事件： next: RACSignal 通过 next 事件向订阅者传送新的值，并且这个值可以为 nil。 error ：RACSignal 通过 error 事件向订阅者表明信号在正常结束前发生了错误。 completed ：RACSignal 通过 completed 事件向订阅者表明信号已经正常结束，后续的值不会发送给订阅者。 这里会产生一个疑问，我们怎么给 RACSignal 添加订阅者？它有一个很核心的方法 subscribe，这是订阅者和信号源建立联系的关键，所以所有的子类都必须实现，并且我们发现所有的子类实现其实都会传递一个实现了 RACSubscriber 的类，并返回一个 RACDisposable 对象。 12345- (RACDisposable *)subscribe:(id)subscriber &#123; NSCAssert(NO, @"This method must be overridden by subclasses"); return nil;&#125; RACSubject 是一个可以手动控制的信号，这个相对 RACSignal 有了订阅者之后就会自动发送信号，而 RACSubject 是可控的，类似插排上面每个插头有额外添加了开关。类比代码中，就是它既是 RACSignal 的子类又实现了 RACSubscriber 协议。但正因为如此，官方反倒建议我们尽量少使用它。 RACSequence 从图上来看其实它跟 RACSignal 是并列的，也没有太直接的关系，而 RACSequence 通常是为了简化 Objective-C 中的集合操作。 订阅者：RACSubscriber 的实现类及其子类RACSubscriber 是一个协议，所有实现了该协议的类都可以成为订阅者。 其中 -sendNext: 、-sendError: 和 -sendCompleted 分别用来从 RACSignal 接收 next 、error 和 completed 事件，而 -didSubscribeWithDisposable: 则用来接收代表某次订阅的 disposable 对象。 调度器：RACScheduler 及其子类 主要为对 GCD 的封装，包含了一些同步异步及定时器的操作。 清洁工：RACDisposable 及其子类 最核心的方法 dispose，其实就是取消所有的订阅，类似于家里订阅了报纸、牛奶，一天你突然不想订了，取消掉。 相关资料： https://github.com/ReactiveCocoaChina/ReactiveCocoaChineseResources http://www.cocoachina.com/ios/20160106/14880.html http://www.cocoachina.com/ios/20140115/7702.html]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhotoKit 框架相关总结]]></title>
    <url>%2F2016%2F03%2F17%2FPhotoKit%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[PhotoKit 中相关类介绍 PHAsset：代表一个照片库中的一个资源，如一个照片/一个视频 PHFetchResult：PHAsset 的集合，对应照片应用中的一个相册 PHFetchOptions：可以通过配置对资源进行排序，如时间 PHImageManager：用于从 PHFetchResult 中获取 PHAsset，可以设置相关参数，获取视频/图片/或者将一个PHAsset转化为NSData PHImageRequestOptions：获取 PHAsset 资源时的相关设置，获取资源的方式(同步/异步)，资源的质量等。 获取相册// 列出所有相册智能相册 PHFetchResult *smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:nil]; [smartAlbums enumerateObjectsUsingBlock:^(PHAssetCollection * _Nonnull collection, NSUInteger idx, BOOL *stop) { [self.dataArray addObject:collection]; }]; // 列出所有用户创建的相册 PHFetchResult *topLevelUserCollections = [PHCollectionList fetchTopLevelUserCollectionsWithOptions:nil]; [topLevelUserCollections enumerateObjectsUsingBlock:^(PHAssetCollection * _Nonnull collection, NSUInteger idx, BOOL *stop) { [self.dataArray addObject:collection]; }]; 当然在这里我们可以在加入集合前对某些相册进行过滤，如全景图片，最近删除我在项目中会直接将全景图片过滤掉，当然也可以只去在特定需求下仅仅展示特定的相册，这里主要会用到 PHAssetCollection 里 assetCollectionSubtype 和 assetCollectionType 属性，当然这些属性可以直接在 PhotosTypes.h 文件下找到： 如： PHAssetCollectionSubtypeSmartAlbumUserLibrary 用户相册PHAssetCollectionSubtypeSmartAlbumPanoramas 全景图片PHAssetCollectionSubtypeSmartAlbumFavorites 个人收藏PHAssetCollectionSubtypeSmartAlbumScreenshots 屏幕快照PHAssetCollectionSubtypeSmartAlbumSelfPortraits 自拍PHAssetCollectionSubtypeSmartAlbumPanoramas 全景照片PHAssetCollectionSubtypeSmartAlbumTimelapses 延时视频PHAssetCollectionSubtypeSmartAlbumRecentlyAdded 最近添加PHAssetCollectionSubtypeSmartAlbumBursts 连拍PHAssetCollectionSubtypeSmartAlbumVideos 视频 1000000201 最近删除 获取相册名称NSString *localizedTitle = assetCollection.localizedTitle 此时我们获取的资源集合在PHAssetCollection中，我们需要将其转化为PHFetchResult： PHFetchResult *fetchResult = [PHAsset fetchAssetsInAssetCollection:assetCollection options:nil]; 当然还可以对资源继续时间/描述等排序： /** 对相册资源继续排序 @param collection collection @return 返回按时间倒序后的集合 */ -(PHFetchOptions *)fetchOptions { PHFetchOptions *options = [[PHFetchOptions alloc] init]; options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@"creationDate" ascending:NO]]; return options; } 获取 PHAsset 资源需要使用到 PHImageManager，他是一个单例对象，通过 PHAsset 对象我们可以获取到我们真正使用的图像或者视频资源。 如相片： PHImageRequestOptions *imageRequestOptions = [[PHImageRequestOptions alloc] init]; imageRequestOptions.networkAccessAllowed = YES; imageRequestOptions.resizeMode = PHImageRequestOptionsResizeModeFast; imageRequestOptions.deliveryMode = PHImageRequestOptionsDeliveryModeOpportunistic; [[PHImageManager defaultManager] requestImageDataForAsset:asset options:options resultHandler:^(NSData * _Nullable imageData, NSString * _Nullable dataUTI, UIImageOrientation orientation, NSDictionary * _Nullable info) { }]; 如视频： PHVideoRequestOptions *options = [[PHVideoRequestOptions alloc] init]; options.networkAccessAllowed = YES; options.version = PHVideoRequestOptionsVersionOriginal; options.deliveryMode = PHImageRequestOptionsDeliveryModeOpportunistic; [[PHImageManager defaultManager] requestAVAssetForVideo:asset options:options resultHandler:^(AVAsset * _Nullable avAsset, AVAudioMix * _Nullable audioMix, NSDictionary * _Nullable info) { }]; 关于 options 的具体参数可以查看各自的头文件，这里很重要的一点是 requestImageDataForAsset/requestAVAssetForVideo 接口返回的 PHImageRequestID，可见 Apple 将开发者获取相册资源看做是一个请求，通常由于 PHAsset 都在本地，即使读取有一个 IO 及内存拷贝的操作，如果不是极限要求通常还是比较快的，但是我们知道相册中的资源是可以同步到 iCloud 中的，此时 requestID 的作用就体现出来了，我们可以在重新选择需要的资源时，可以将上次还没有从 iCloud 中同步过来的资源进行取消操作，就像这样 [[PHImageManager defaultManager] cancelImageRequest:self.lastPHImageRequestID]; 监听相册数据变化当应用获取到用户授权可以访问相册资源时，很重要的一点就是我们如果同步相册中的资源，如用户将应用挂起后，重新拍了一张照片、录了一段新的视频、截图，甚至是将相册中的资源进行了删除，当然后者更为严重，这将导致极端情况下再返回应用时可能导致数据错乱甚至崩溃。好在 Apple 为我们提供了 PHPhotoLibraryChangeObserve。我们可以在程序中需要的地方添加监听，然后在不需要时进行移除。 [[PHPhotoLibrary sharedPhotoLibrary] registerChangeObserver:self]; #pragma mark PHPhotoLibraryChangeObserver - (void)photoLibraryDidChange:(PHChange *)changeInstance { } -(void)dealloc { [[PHPhotoLibrary sharedPhotoLibrary] unregisterChangeObserver:self]; } 这个代理方法，会在相册中数据有任何变化，例如相册中资源被删除、被编辑、添加了新照片、视频等，当我们再次回到应用时都自动进行回调。另外当我们在应用中同步了 iCloud 的资源，那么也会回调次方法。 最后PHAsset 是属于 iPhone 相册相关操作范围内的概念，PHAsset 并不是一个真正意义上的一个文件，我们通常获取到 PHAsset 后需要将真正的文件保存到沙盒中再将其上传到 CDN。推荐阅读ALAsset/PHAsset 中的图片和视频文件 相关资料：https://developer.apple.com/reference/photos/phphotolibrarychangeobserver?language=objc]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django 数据库同步及创建管理员]]></title>
    <url>%2F2016%2F01%2F28%2Fdjango%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E7%AE%A1%E7%90%86%E5%91%98%2F</url>
    <content type="text"><![CDATA[数据库同步首先在项目 setting.py 下对需要修改对应的 DATABASES 定义，对应的我们需要创建一个名为 djangodemo 的数据库并保证我们的MySQL服务是开启的： 12345678910111213# Database# https://docs.djangoproject.com/en/1.9/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'djangodemo', 'USER': 'root', 'PASSWORD': '111111', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;&#125; 执行命令： 12python manage.py makemigrationspython manage.py migrate 使用安装 MySQLWorkbench 打开数据库查看表，django 已经自动为我们创建基本用户、组、日志、seesion 的表： 创建 admin 帐号 首先我们要新建一个用户名，用来登陆管理网站，可以使用如下命令： python manage.py createsuperuser 输入想要使用的用户名： Username (leave blank to use ‘administrator’): user01 输入email： Email address: (在这里输入你的自己的邮箱帐号) 输入密码，需要输入两次，并且输入密码时不会显示出来： Password: Password (again): 当两次密码都相同的时候，就会提示超级帐号创建成功。 Superuser created successfully. 运行服务： python manage.py runserver 浏览器地址栏输入：http://127.0.0.1:8000/admin 登陆成功后我们既可以添加新的用户和对用户的权限进行添加移除等操作： 查看auth_user表我们就可以看到我们创建的admin超级管理员账号及一个子用户：]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 django 搭建网站]]></title>
    <url>%2F2016%2F01%2F27%2F%E5%88%9D%E8%AF%86Django%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[开发工具 python 2.7.10 PyCharm 5.0.2 django 1.9.1 推荐使用 PyCharm 直接进行 django 框架的安装，当然 https://www.djangoproject.com/download/ 也有使用pip安装的详细说明。 创建项目关于 app 的概念，比如NGA www.nga.cn下包含了论坛http://bbs.nga.cn/、还会有直播http://tv.nga.cn/，从运维上讲代表不同的配置段 app1 和 app2 可以连接不同的数据库，占用不同的进程，不一样的 IP 地址和服务器 因为 html 是跳链，所以你感觉不到 IP 的不同。 目录结构 setting.py 包括了系统的数据库配置、应用配置和其他配置 urls.py 表示 web 工程 Url 映射的配置 子目录 demo 则是在该工程下创建的 app，包含了 models.py、tests.py 和 views.py 等文件 templates 目录则为模板文件的目录 manage.py 是 Django 提供的一个管理工具，可以同步数据库等等 项目的入口是 manage.py 文件，首先加载的是 settings.py 文件，这个是我们的项目配置文件。包含了 django 自带的一些 app，指定文件模板的路径，及相关的数据库配置，默认情况下使用的是 sqlite3，在这里我们使用 MySQL。需要修改对应的 DATABASES定义，对应的我们需要创建一个名为 djangodemo 的数据库并保证我们的MySQL服务是开启的： 123456789101112131415161718# Database# https://docs.djangoproject.com/en/1.9/ref/settings/#databasesDATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'djangodemo', 'USER': 'root', 'PASSWORD': '111111', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;&#125;``` 在 Terminal 下运行项目：``` pythonpython manager.py runserver 此时我们就已经可以在浏览器中访问 http://127.0.0.1:8000/了，效果如图： 当然这是在 Debug 下，正式发布部署的时候服务器上运行的 django 项目应当设置 DEBUG=False，修改关闭 DEBUG, 这样不法分子便无法从 debug 信息中找到对他们有用的信息. 在设置 DEBUG=false 后, 一定要正确设置 ALLOWED_HOSTS, 避免出现 SuspiciousOperation 错误。 创建第一个视图函数在 views.py 文件下添加下面的函数，我们定义个一段 html 代码，然后将其返回，当请求一个页面时，Django 把请求的 metadata 数据包装成一个 HttpRequest 对象，然后 Django 加载合适的 view 方法，把这个 HttpRequest 对象作为第一个参数传给 view 方法。任何 view 方法都应该返回一个 HttpResponse 对象。 12345678import datetimefrom django.http import HttpResponsedef sayHello(request): s = 'Hello World!' current_time = datetime.datetime.now() html = '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; %s &lt;/h1&gt;&lt;p&gt; %s &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;' % (s, current_time) return HttpResponse(html) 修改url.py文件，进行url映射的配置: 1url(r'^sayHello/', sayHello), 此时我们就已经可以在浏览器中访问 http://127.0.0.1:8000/sayHello/ 了，效果如图： 创建第一个模板文件在 django 中所有的模板文件均是放在 templates 文件夹下，下面创建一个页面模板，命名为 index.html。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;粤语歌单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;我常听的歌曲排名&lt;/h2&gt; &lt;ul&gt; &#123;% if list %&#125; &#123;% for value in list %&#125; &lt;li&gt; 排名第&#123;&#123; forloop.counter&#125;&#125;位:&#123;&#123;value&#125;&#125; &lt;/li&gt; &#123;% endfor %&#125; &#123;% endif %&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 在视图文件中添加视图 view，并命名为 songList，引入 from django.shortcuts import render_to_response 模块，response 将会已我们制定的模板进行渲染，注意参数 list 需要与模板中遍历的参数相同： 123def songList(request): list = ["钟无艳", "够钟", "一丝不挂", "失忆蝴蝶", "献世"] return render_to_response('index.html',&#123;'list': list&#125;) 在 url.py 文件中配置 url，我们可以使用这种写法，便于业务的区分： 123urlpatterns += [ url(r'^songList/', songList),] 此时服务之前是已经开启了，所以我们可以直接在浏览器中进行访问 http://127.0.0.1:8000/songList/了，效果如图：]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个爬虫-爬取糗百热门段子并存储在 MySQL 数据库中]]></title>
    <url>%2F2016%2F01%2F26%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB-%E7%88%AC%E5%8F%96%E7%B3%97%E7%99%BE%E7%83%AD%E9%97%A8%E6%AE%B5%E5%AD%90%E5%B9%B6%E5%AD%98%E5%82%A8%E5%9C%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[创建项目主要为爬取糗事百科上热门段子资源，在Terminal下执行命令，参数为项目名。 1scrapy startproject qiubai 项目目录结构说明1234567qiubai/ qiubai/ __init__.py items.py //项目的items文件 pipelines.py //项目的pipelines文件 settings //项目的设置文件 scrapy.cfg //项目的配置文件 明确目标，定义 item在 Scrapy 中，items 是用来加载抓取内容的容器，有点类似 iOS 中的 model 模型，可以理解成类似于 ORM 的映射关系，但是提供了一些额外的保护减少错误。 在qiubai目录下的 items.py 文件，在后面添加我们自己的 class hotItem，包含了头像、昵称、内容、点赞数量及评论数： 123456789import scrapyclass hotItem(scrapy.Item): # define the fields for your item here like: avatar = scrapy.Field() nickname = scrapy.Field() content = scrapy.Field() like = scrapy.Field() commentNum = scrapy.Field() 制作爬虫Spider 是用户自己编写的类，用来从一个域（或域组）中抓取信息。他们定义了用于下载的URL列表、跟踪链接的方案、解析网页内容的方式，以此来提取 items。要建立一个 Spider，你必须用 scrapy.spider.BaseSpider 创建一个子类，并确定三个强制的属性： name：爬虫的识别名称，必须是唯一的，在不同的爬虫中你必须定义不同的名字。 start_urls：爬取的URL列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些 urls 开始。其他子 URL 将会从这些起始URL中继承性生成。 parse()：解析的方法，调用的时候传入从每一个 URL 传回的 Response 对象作为唯一参数，负责解析并匹配抓取的数据(解析为 item )，跟踪更多的 URL。 接下来定义 Spider，在项目的 /qiubai/spoders 目录下，并设置了 spider 的名字、爬虫的约束范围，及网页文件进行存储 123456789101112131415import scrapyclass qiubaiSpider(scrapy.spiders.Spider): name = "hot" allowed_domains = ["qiushibaike.com/"] start_urls = [ "http://www.qiushibaike.com/hot/page/1", "http://www.qiushibaike.com/hot/page/2" ] def parse(self, response): filename = response.url.split("/")[-1] print(filename) with open(filename, 'wb') as f: f.write(response.body) 爬执行爬虫文件 1scrapy crawl hot 我这里遇到了下面的的问题，导致抓取失败。 122016-01-07 17:24:03 [scrapy] DEBUG: Gave up retrying &lt;GET http://www.qiushibaike.com/hot/page/1&gt; (failed 3 times): [&lt;twisted.python.failure.Failure &lt;class &apos;twisted.internet.error.ConnectionDone&apos;&gt;&gt;]2016-01-07 17:24:03 [scrapy] ERROR: Error downloading &lt;GET http://www.qiushibaike.com/hot/page/2&gt;: [&lt;twisted.python.failure.Failure &lt;class &apos;twisted.internet.error.ConnectionDone&apos;&gt;&gt;] 其实之前是爬的韩寒的新浪博客，并且成功爬了下来。替换成糗百后才才出现了上面的错误，所以我猜想是不是糗百对user-agent进行了限制，所以开始为scrapy爬虫添加随机UA： 1、在settings.py中添加以下代码，注意修改对应自己的项目名称 12345DOWNLOADER_MIDDLEWARES = &#123; 'qiubai.random_user_agent.RandomUserAgentMiddleware': 400, 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,&#125; 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/python#-*-coding:utf-8-*-import randomfrom scrapy.downloadermiddlewares.useragent import UserAgentMiddlewareclass RandomUserAgentMiddleware(UserAgentMiddleware): def __init__(self, user_agent=''): self.user_agent = user_agent def process_request(self, request, spider): #这句话用于随机选择user-agent ua = random.choice(self.user_agent_list) if ua: request.headers.setdefault('User-Agent', ua) #the default user_agent_list composes chrome,I E,firefox,Mozilla,opera,netscape #for more user agent strings,you can find it in http://www.useragentstring.com/pages/useragentstring.php user_agent_list = [\ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1"\ "Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11",\ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6",\ "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6",\ "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1",\ "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5",\ "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5",\ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",\ "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",\ "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3",\ "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",\ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3",\ "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",\ "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",\ "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",\ "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3",\ "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24",\ "Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24" ] 添加完成之后，再次执行就OK了。可以在项目根目录下看到1和2两个文件，其实里面的内容是html源代码，当然这仅仅是演示爬取的过程，接下来就是对源码进行解析。 以上这个过程主要是我们将使用创建的爬虫 hot，把 start_urls 里指定的每个URL创建了一个 scrapy.http.Request 对象 ，并将爬虫的 parse 方法指定为回调函数，在这里我们仅仅进行了保存操作。然后，这些 Request 被调度并执行，之后通过 parse() 方法返回 scrapy.http.Response 对象，并反馈给爬虫。 取在基础的爬虫里，这一步可以用正则表达式来抓。在 Scrapy 里，使用一种叫做 XPath selectors的机制，它基于 XPath 表达式。如果你想了解更多 selectors 和其他机制你可以查阅资料：选择器(Selectors) 简单的罗列一下有用的xpath路径表达式：1234567 表达式 描述nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 下面是一些 XPath 表达式的例子和他们的含义： //div[@class=”stats”]: 选择所有包含 class=”stats” 属性的div 标签元素 //td: 选择所有 元素 /title/text(): 选择前面提到的 元素下面的文本内容 接下来我们将对应的源码标签解析，并将对象保存在 items 列表中，对象保存段子的作者昵称头像等内容，我们主要解析的就是下面这段内容： 修改我们的Spider中的解析逻辑： import scrapy from scrapy.selector import Selector from qiubai.items import hotItem class qiubaiSpider(scrapy.spiders.Spider): name = "hot" allowed_domains = ["qiushibaike.com/"] start_urls = [ "http://www.qiushibaike.com/hot/page/1", "http://www.qiushibaike.com/hot/page/2" ] def parse(self, response): sel = Selector(response) sites = sel.xpath('//div[@class="article block untagged mb15"]') items = [] for site in sites: item = hotItem() userSites = site.xpath('div[@class="author clearfix"]//a') # 有些时候此标签并不一定存在，需要进行判断 if userSites: item["avatar"] = userSites[0].xpath('img/@src').extract() item["nickname"] = userSites[1].xpath('h2/text()').extract() item["content"] = site.xpath('div[@class="content"]/text()').extract() num = site.xpath('div[@class="stats"]//i') item["like"] = num[0].xpath("text()").extract() item["commentNum"] = num[1].xpath("text()").extract() items.append(item) return items 存储爬取的内容保存信息的最简单的方法是通过 Feed exports，主要有四种数据格式：JSON，JSON lines，CSV，XML。我们将结果用最常用的 JSON 导出，命令如下： -o 后面是导出文件名，-t 后面是导出类型。 scrapy crawl hot -o items.json -t json 此时就可以在项目跟目录下看到 items.json 文件，可以使用文本编辑器查看了。当然我们更多的时候还是希望保存到 MySQL中便于使用，这时候就需要使用到 pipelines.py 文件了。 当然还需要修改 setting.py 这个文件：将下面这句话加进去 ITEM_PIPELINES=[&apos;fjsen.pipelines.QiubaiPipeline&apos;] 并且修改在 pipelines.py 文件，修改对应的数据库账户密码，建议制定为 utf8 编码，否则会出现乱码。并且推荐使用这种方法进行数据插入，写 sql 语句出错太难调了。 from scrapy import log from twisted.enterprise import adbapi import MySQLdb import MySQLdb.cursors class QiubaiPipeline(object): def __init__(self): self.dbpool = adbapi.ConnectionPool('MySQLdb', db='qiubaiDB', user='root', passwd='111111', cursorclass = MySQLdb.cursors.DictCursor, charset='utf8', use_unicode=True) def process_item(self, item, spider): # run db query in thread pool query = self.dbpool.runInteraction(self._conditional_insert, item) query.addErrback(self.handle_error) return item def _conditional_insert(self, tx, item): # create record if doesn't exist. # all this block run on it's own thread isExist =tx.execute('select *from information_schema.tables where table_name = "hot"') if isExist: sql = "INSERT INTO hot(hot_avatar, hot_nickname, hot_content, hot_like, hot_commentNum) VALUES (%s, %s, %s, %s, %s)" avatar = item["avatar"] param = "" # 需要判断头像昵称是否真的存在，当然这个判断条件写的比较简单 if avatar: param = (item['avatar'][0], item["nickname"][0], item['content'][0], int(item['like'][0]), int(item['commentNum'][0])) else: param = ("", "", item['content'][0], int(item['like'][0]), int(item['commentNum'][0])) tx.execute(sql, param) else: # 如果表不存在则创建 tx.execute('create table hot(hot_id INT AUTO_INCREMENT PRIMARY KEY, hot_avatar VARCHAR(100) , hot_nickname VARCHAR(100) , hot_content text NOT NULL, hot_like INT NOT NULL,hot_commentNum INT NOT NULL) DEFAULT CHARSET=utf8') def handle_error(self, e): log.err(e) 接着，执行爬虫命令后查看数据库就可以了，在此之前确保你的 MySQL 服务是启动的：]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装爬虫框架 Scrapy 遇到的问题及解决方法]]></title>
    <url>%2F2016%2F01%2F06%2F%E5%AE%89%E8%A3%85%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6Scrapy%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关于环境MAC OS :10.10 安装 Scrapy依然像安装 MySQL-python 模块一样，在终端下使用 pip 进行安装： 1sudo pip install Scrapy 如果下载完成后提示 successful installed Scrapy，那么 Scrapy 就安装成功了。但通常都事与愿违，我在安装的时候遇到了这样的一个错误： 12345678910111213/tmp/xmlXPathInitIVW9Pp.c:1:10: fatal error: 'libxml/xpath.h' file not found#include "libxml/xpath.h" ^1 error generated.*********************************************************************************Could not find function xmlCheckVersion in library libxml2. Is libxml2 installed?Perhaps try: xcode-select --install*********************************************************************************error: command 'cc' failed with exit status 1----------------------------------------Command "/System/Library/Frameworks/Python.framework/Versions/2.7/Resources/Python.app/Contents/MacOS/Python -c "import setuptools, tokenize;__file__='/private/tmp/pip-build-LpH_ul/lxml/setup.py';exec(compile(getattr(tokenize, 'open', open)(__file__).read().replace('\r\n', '\n'), __file__, 'exec'))" install --record /tmp/pip-XfCz9W-record/install-record.txt --single-version-externally-managed --compile" failed with error code 1 in /private/tmp/pip-build-LpH_ul/lxml 解决方法有如下几种： 1、终端执行命令安装或更新命令行开发工具： 1xcode-select --install 2、配置路径：C_INCLUDE_PATH 1C_INCLUDE_PATH=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libxml2:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libxml2/libxml:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include 3、参照官网使用如下命令安装 Scrapy 1STATIC_DEPS=true pip install lxml 一般此三个方法就可解决错误成功安装Scrapy，如果还是失败，只能再去 baidu/google/StackOverflow 上寻找同样的错误。我使用的是第一种方法，成功的安装了 Scrapy。 1Successfully installed Scrapy-1.0.4 characteristic-14.3.0 lxml-3.5.0 pyasn1-0.1.9 pyasn1-modules-0.0.8 service-identity-14.0.0 但是在终端下使用 scrapy 命令确又出现错误 123456789101112Traceback (most recent call last): File "/usr/local/bin/scrapy", line 7, in &lt;module&gt; from scrapy.cmdline import execute File "/Library/Python/2.7/site-packages/scrapy/__init__.py", line 48, in &lt;module&gt; from scrapy.spiders import Spider File "/Library/Python/2.7/site-packages/scrapy/spiders/__init__.py", line 10, in &lt;module&gt; from scrapy.http import Request File "/Library/Python/2.7/site-packages/scrapy/http/__init__.py", line 12, in &lt;module&gt; from scrapy.http.request.rpc import XmlRpcRequest File "/Library/Python/2.7/site-packages/scrapy/http/request/rpc.py", line 7, in &lt;module&gt; from six.moves import xmlrpc_client as xmlrpclibImportError: cannot import name xmlrpc_client 最后查到是因为 six 这个 module 有问题导致，卸载之，重新通过 easy_install six安装后即可： 12sudo pip uninstall six sudo easy_install six 之后我们就可以使用 scrapy 命令了： 12scrapy version//查看版本scrapy startproject test//创建项目]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过去的2015]]></title>
    <url>%2F2015%2F12%2F31%2F%E8%BF%87%E5%8E%BB%E7%9A%842015%2F</url>
    <content type="text"><![CDATA[2015年终究觉得比往年过得慢一些，对某些事依旧耿耿于怀，对某些人仍然念念不忘，删掉了三年来所有的微博，生怕再勾起某些回忆。生活依旧过得不好不坏，换了工作搬了家，每天步行20分钟上班，不再为每天上下班痛苦的挤地铁而烦恼。工作也早已得心应手，可以花更多的时间与精力做自己喜欢的事情，也越发觉得写代码是件多么有趣的事。也意识到身体健康的重要性，现在跑10公里已经没有那么的累，好在跑步虽是自己一直断断续续但仍旧坚持下来的一个习惯。 也领悟到了钱真的可以买来快乐，当吃到好吃的，买到喜欢的东西那一刻心总是能得到莫大的安慰，并且屡试不爽。 anyway，还是坚强而乐观的活着，这个就够了，其他真的都不重要。]]></content>
      <tags>
        <tag>生活</tag>
        <tag>呵呵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 下的 Python 环境搭建及 MySQL-python 模块安装]]></title>
    <url>%2F2015%2F12%2F25%2FMac%E4%B8%8B%E7%9A%84Python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8AMySQL-python%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[关于环境MAC OS :10.10 PyCharm :推荐使用，最开始使用的是 Sublime Text 加终端的方式，但是来回切换实在太繁琐，后来切换到了 PyCharm 下，好的 IDE 真是会使效率事半功倍，更重要还提供了一些很好用的功能用于Django框架开发。 安装 MySQL由于之前一直做移动开发，并没有真正使用过 MySQL，而 MySQL 数据库在第一次安装后出现了各种莫名其妙的问题，无论是使用系统偏好设置启动，还是终端启动服务均失败，总是出现各种 permission failed或Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’等问题，各种方法使用后无解还是尝试重新安装。MySQL下载地址，一定要选择对应的系统版本及位数。 重新安装前一定要将原本机器上的MySQL删除干净，建议使用终端方法进行删除，注意安装完成后会弹出提示，提示中 password 就是 MySQL 的 root 密码： 123456789sudo rm /usr/local/mysqlsudo rm -rf /usr/local/mysql*sudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My*vim /etc/hostconfig (复制前面部分回车，然后删掉这一行: MYSQLCOM=-YES-，control+O回车保存，control+X退出编辑界面) rm -rf ~/Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /var/db/receipts/com.mysql.* 安装 MySQLWorkbench 安装完成后创建链接，此时会提示让你修改 MySQL 的 root 密码，此时输入安装 MySQL 时保存的旧密码设置新密码就可以了 使用系统偏好设置输入密码打开 MySQL 服务 使用 MySQLWorkbench 链接数据库，此时我们就可以使用 MySQLWorkbench 可视化创建我们的数据库和表了，而这些并不需要我们输入 sql 语句就可以完成 安装MySQL-python模块要想使Python可以操作Mysql需要 MySQL-python 驱动，它是 Python 操作 MySQL 必不可少的模块。 安装此模块前必须机器上成功安装了 MySQL 数据库并可以成功开启MySQL服务 使用pip在终端下进行安装：sudo pip install MySQL-python pip在我们安装PyCharm后既可以直接在终端下直接使用，可以快速安装一些Python的开发包 测试Python测试 MySQL-pytho n模块 事先已经使用 MySQLWorkbench 创建了数据库及一张学生表 需要修改对应的 root 密码及端口号、及要查询的数据库表名 1234567891011121314151617181920# coding=utf-8import MySQLdbtry:conn=MySQLdb.connect(host='localhost',user='root',passwd='111111',db='test',port=3306) cur=conn.cursor() students = cur.execute('SELECT * FROM student') info = cur.fetchmany(students) for ii in info: print ii cur.close() conn.close()except MySQLdb.Error,e: print "Mysql Error %d: %s" % (e.args[0], e.args[1])数据库查询的数据信息：(1L, '\xe5\xbc\xa0\xe4\xb8\x89', 11L, 1L)(2L, '\xe6\x9d\x8e\xe5\x9b\x9b', 13L, 2L)(9L, '\xe7\x88\xb1\xe4\xb8\x8a', 11L, 2L)(15L, '\xe9\xbb\x84\xe9\x87\x91\xe5\xae\xa2\xe6\x88\xb7', 11L, 2L) 下来我们就可以开始Django框架的学习了。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSPatch 使用小结]]></title>
    <url>%2F2015%2F12%2F03%2FJSPatch%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[众所周知，iOS 应用审核机制，所以当我们的线上应用面对突如起来的 bug 的时候会显得很手足无措，有时候仅仅可能就是添加一两行代码解决这个问题却要因为审核等待一周或者美国人过节就会有甚至更长的审核周期。所以hoxfix热修复的作用简直就是掉炸天的功能啊。而 JSPatch 就是这样一个极小的轻量级框架，它可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。 关于 JSPatchGITHUB地址，除了查看demo运行外，在 Wiki里面我们也可以看到更详细的介绍说明。安装同样支持 cocoaPod，快捷方便。这里不具体更多的说明，只是记录下再使用的过程中的关键点。 服务端的patch文件部署问题这里我们将补丁文件打包后通过存放在自己的服务器上，按照 JSPatch Loader 使用文档使用说明，采用版本名作为文件夹，然后将对应的补丁文件存放在对应文件夹下，并修改 JPLoader 的 rootUrl 为对应的服务器地址即可。可是考虑到服务器地址写死在本地可能后期补丁文件可能放在另一台服务器的情况或者不可控的因素，最终还是让服务器端将完整的补丁文件地址返回给客户端，而客户端也不去关心服务器端是否按照什么样的逻辑或者方式去存放补丁文件。而这样做我们就需要修改 JPLoader 下的 + (void)updateToVersion:(NSInteger)version callback:(JPUpdateCallback)callback；方法实现修改为下面的逻辑，虽然我通常不建议修改第三方库文件。 + (void)updateToVersion:(NSInteger)version patchpath:(NSString *)patchpath callback:(JPUpdateCallback)callback; { NSString *appVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"]; if (JPLogger) JPLogger([NSString stringWithFormat:@"JSPatch: updateToVersion: %@", @(version)]); // create url request // NSString *downloadKey = [NSString stringWithFormat:@"/%@/v%@.zip", appVersion, @(version)]; // NSURL *downloadURL = [NSURL URLWithString:[rootUrl stringByAppendingString:downloadKey]]; NSURL *downloadURL = [NSURL URLWithString:patchpath]; NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:20.0]; if (JPLogger) JPLogger([NSString stringWithFormat:@"JSPatch: request file %@", downloadURL]); * * * // success if (!isFailed) { if (JPLogger) JPLogger([NSString stringWithFormat:@"JSPatch: updateToVersion: %@ success", @(version)]); [[NSUserDefaults standardUserDefaults] setInteger:version forKey:kJSPatchVersion(appVersion)]; [[NSUserDefaults standardUserDefaults] setObject:patchpath forKey:kLASTPATCHPATH(appVersion)]; [[NSUserDefaults standardUserDefaults] synchronize]; if (callback) callback(nil); } // clear temporary files [[NSFileManager defaultManager] removeItemAtPath:downloadTmpPath error:nil]; [[NSFileManager defaultManager] removeItemAtPath:unzipVerifyDirectory error:nil]; [[NSFileManager defaultManager] removeItemAtPath:unzipTmpDirectory error:nil]; } else { if (JPLogger) JPLogger([NSString stringWithFormat:@"JSPatch: request error %@", error]); if (callback) callback(error); } }]; [task resume]; } 这样在参数里面直接写入下载地址，而不考虑通过 rootUrl 和版本号拼接的方式。 更新机制由于我们每次调用 JSPatch 的 updateToVersion 方法都会重新下载一次补丁文件，而这样显得并不是那么必要，所以客户端当检测到这次请求下载补丁地址与上一次的补丁地址相同的情况下，就不再调用 updateToVersion 方法，而上一次的的补丁地址我们会在上一次文件下载成功的回调里面通过 NSUserDefaults 保存起来，而原作者也是通过此方式将补丁的版本号保存在了 NSUserDefaults 里。 [[NSUserDefaults standardUserDefaults] setInteger:version forKey:kJSPatchVersion(appVersion)]; [[NSUserDefaults standardUserDefaults] setObject:patchpath forKey:kLASTPATCHPATH(appVersion)]; [[NSUserDefaults standardUserDefaults] synchronize]; 更新频率也就是我们刷新最新补丁接口的频率。首先我们应该按照作者的建议在程序启动的 -application:didFinishLaunchingWithOptions: 里第一句调用 run 这个接口，防止调用后执行 JSPatch 脚本过程中其他线程同时在执行相关代码，导致意想不到的问题。而刷新频率建议放在 applicationDidBecomeActive 这个方法里，并建议设置每隔1个小时检查一次。 最后在线的 OC 转 JS 代码工具 JSPatchConvertor，这里作者真得是很用心，基本的功能都实现了，更多的可以参考 JSPatch 基础用法，当然面对复杂的结构还是需要我们自己手动进行修改成JS代码的，因为它还不够聪明。比如我们在使用SDWebImage框架的时候，工具修改后的imageView.sdsetImageWithURL，而这样会直接导致崩溃，需要修改为两个下划线就可以了；而当抛出 ‘js exception: SyntaxError: At least one digit must occur after a decimal point’这样的错误可能就是因为我们出现的float数值后有了f字母。细节上更多的还是需要我们参考文档说明。 当然我们遇到了 bug 时，除了第一时间发布补丁，还是应该在新的版本中使用 OC 对 bug 进行修改，毕竟使用 JSPatch 还是一个紧急措施。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIKit 的性能优化]]></title>
    <url>%2F2015%2F11%2F04%2FUIKit%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[主要为阅读一些博客和书籍，对一些 UIKit 方便的性能优化的一些知识点进行了整理 尽量避免图层的混合 避免使用控件的 opaque 属性将其透明，当然默认的情况下 UIVie 的 opaque 属性就是 true，同时尽量将UIView的背景颜色设置与其父控件相同且不是透明的 没有特殊情况下不要设置控件的 alpha 值降低透明度 使用 UIImage 尽量使用没有带 alpha 通道图片 图层的混合首先对于像素点，屏幕上的每一个点就是一个像素，像素有R/G/B三种颜色构成，某些时候还要有 alpha 值。 举个栗子，我们将两个图层混合，上层的是蓝色（R=0/G=0/B=1）,设置其透明度为50%，下层是红色（R=1/G=0/B=0）,那么最终我们看到的效果将是紫色（R=0.5/G=0/B=0.5）,这种颜色的混合，尤其上层的图层有透明度的时候，会小号一定的GPU资源，想避免这种情况，尽量直接将上层的图层透明度设置为100%，这样GPU就会忽略下面的所有图层，避免了过多不要的运算。 关于图层的混合算法GPU会通过图上图层和下图层的颜色进行图层混合，计算出混合部分的颜色，最理想情况的计算公式如下： R = S + D * ( 1 – Sa ) 其中，R表示混合结果的颜色，S是源颜色(上层的蓝色图层色)，D是目标颜色位于下层的红色图层，Sa是源颜色的alpha值，即透明度。公式中所有的S和D颜色都假定已经预先乘以了他们的透明度。知道图层混合的基本原理以后，再回到正题说说opaque属性的作用。当UIView的opaque属性被设为YES以后，按照上面的公式，也就是Sa的值为1，这个时候公式就变成了：R = S即不管D为什么，结果都一样。因此GPU将不会做任何的计算合成，不需要考虑它下方的任何东西(因为都被它遮挡住了)，而是简单从这个层拷贝。这节省了GPU相当大的工作量。由此看来，opaque属性的真实用处是给绘图系统提供一个性能优化开关！ 尽量避免临时图像的转换 确保图片的大小与控件frame一致，避免对图片进行缩放 确保像素格式被GPU支持，避免增加 CPU 针对格式的转换 关于图片的格式，一张640*960的照片一共有61440个像素，而我们已经知道每个像素有 R/G/G 三个值，某些格式的图片还会带 alpha 通道，那每个值占用1个字节，那么这样一张大小的图片大小就会将近 2M，但是通常一张图片并不会有这么大，这是因为我们常见PNG或者JPG已经将像素数据进行了一种非常复杂且可逆的转化。而当我们打开图片的时候，CPU首先会将图片解压成像素数据，再将其交给 GPU 进行渲染。而GPU如果不支图片像素格式，那么将让CPU花费额外的经历进行转换。而同样的调整图片大小也样会增加开销。 关于前屏渲染和离屏渲染OpenGL中，GPU 屏幕渲染有以下两种方式： On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：创建新缓冲区要想进行离屏渲染，首先要创建一个新的缓冲区。上下文切换离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。 避免触发离屏渲染 绝大多数时候离屏渲染会影响性能 重写 drawRect 方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染 下面这种图是正常的渲染通道流程 首先OpenGL提交命令道Command Buffer，随后GPU开始渲染，将渲染结果放在Render Buffer中。但是针对一些复杂的效果无法渲染出结果，它需要分步骤渲染再最终组合起来，比如添加蒙版mask: 在前两个渲染通道中，GPU 分别得到了纹理(相机图标)和 layer (蓝色的蒙版)的渲染结果，但这两个渲染结果没有直接放入 Render Buffer 中，也就表示这是离屏渲染。直到第三个渲染通道，才把两者组合起来放入 Render Buffer 中。离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。 所以通常上层设置有透明的话，会产生离屏渲染；而我们接触到的 UINavigationbar、Tabbar 等系统空间的半透明或者毛玻璃效果同样也会产生离屏渲染。 设置阴影效果是加上阴影路径的时候加上阴影路径，因为如果没有指定路径，Core Animation 将自动计算从而触发离屏渲染。认为的设置了阴影路径就会避免计算，从而避免离屏渲染 view.layer.shadowColor = [UIColor blackColor].CGColor;//shadowColor阴影颜色 view.layer.shadowOffset = CGSizeMake(4,4);//shadowOffset阴影偏移,x向右偏移4，y向下偏移4，默认(0, -3),这个跟shadowRadius配合使用 view.layer.shadowOpacity = 0.8;//阴影透明度，默认0 view.layer.shadowRadius = 4;//阴影半径，默认3 view.layer.shadowPath = UIBezierPath(rect: view.bounds).CGPath//设置阴影路径 滑动时若需要圆角效果，开启光栅化，因为使用masksToBounds会触发离屏渲染，所以我们可以开启光栅化将圆角缓存起来。 label.layer.masksToBounds = true label.layer.cornerRadius = 8 label.layer.shouldRasterize = true label.layer.rasterizationScale = layer.contentsScale 当然设置圆角还有很多方式：1、给 UIView 绘制圆角2、如果是 UIImageView 的话，可以直接将图片进行裁剪，当然前提图片不能为空3、可以使用图片遮罩，当然这个第一会使试图增加新的图层，另一方面这个对遮罩图片及视图背景颜色有要求，所以并不建议使用，虽然这种方法简单粗暴。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装 AVPlayer (包含触摸滑动快进/快退 调节音量)及相关注意点]]></title>
    <url>%2F2015%2F08%2F15%2F%E5%B0%81%E8%A3%85AVPlayer-%E5%8C%85%E5%90%AB%E8%A7%A6%E6%91%B8%E6%BB%91%E5%8A%A8%E5%BF%AB%E8%BF%9B-%E5%BF%AB%E9%80%80-%E8%B0%83%E8%8A%82%E9%9F%B3%E9%87%8F-%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[在iOS视频开发中，传统的方案可以直接使用系统的 MPMoviePlayerController 既可以直接将系统的播放页面掉出来，更贴心的为我们添加了控制条，全屏放大及暂停按钮。但是实际中我们可以需要针对播放器做更多的自定义设置，继而更多的是会采用 AVPlayer，因为 AVPlayer 提供了更为强大的功能，虽然在使用的过程会比较麻烦，但是确实能为我们的 app 提供更好的视频播放体验提供前提。 初步认识 AVPlayer在这之前我们先介绍几个相关类： AVPlayerItem：一个视频资源对应一个 AVPlayerItem对象，当你需要循环播放多个视频资源时也需创建多个AVPlayerItem对象，并将其添加在一个数组中。我们可以通过静态方法 playerItemWithURL 进行创建，同样也可以通过 AVAsset，而根据两种创建方法的不同，我们即知道加载本地视频资源还是网络视频资源。 CMTime：关于 CMTime 我们可以很方便的获取到视频资源的精准播放长度长度，及快速让播放器定位到指定时间进行播放。 AVPlayer: AVPlayer 我们能把播放器做得那么溜全靠它了，视频资源就是交给它进行处理的。 AVPlayerLayer: AVPlayerLayer 其实 AVPlayer 仅仅处理视频资源，但是视频的画面其实是加载到AVPlayerLayer上的。 根据以上的简单介绍，我们可以做一个简单的视频播放器，只要仅仅能看到播放画面及听到声音就可以了，这里需要特别注意 AVPlayer 必须设置为成员变量，在局部变量中因为方法执行完后即被释放了会导致视频播放失败： 12345678910NSString *filePath = [[NSBundle mainBundle] pathForResource:@"snow" ofType:@"mp4"];NSURL *sourceMovieURL = [NSURL fileURLWithPath:filePath];AVAsset *movieAsset = [AVURLAsset URLAssetWithURL:sourceMovieURL options:nil];AVPlayerItem *playerItem = [AVPlayerItem playerItemWithAsset:movieAsset];self.player = [AVPlayer playerWithPlayerItem:playerItem];self.playerLayer = [AVPlayerLayer playerLayerWithPlayer:self.player];self.playerLayer.frame = self.view.bounds;self.playerLayer.videoGravity = AVLayerVideoGravityResizeAspect;[self.view.layer insertSublayer:self.playerLayer atIndex:0];[self.player play]; 为我们的播放器添加控制条这一步主要为在播放器上添加常规按钮，如返回、播放/暂停、全屏、播放时间进度条等一些为用户和播放器的交互试图。 首先我们自定义一个 BHPlayerControlView，这里面包含了所有的操作按钮及进度条、展示时间的 Label、当然还包括加载视频缓冲时的菊花 UIActivityIndicatorView，以下主要为设置控制条子试图约束的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 设置子空间约束，采用 Masonry 设置约束，不需要重写 layoutSubviews 方法 */- (void)makeSubViewsConstraints&#123; [self.topImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.trailing.top.equalTo(self); make.height.mas_equalTo(80); &#125;]; [self.backBtn mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(self.mas_leading).offset(15); make.top.equalTo(self.mas_top).offset(5); make.width.height.mas_equalTo(30); &#125;]; [self.bottomImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.trailing.bottom.equalTo(self); make.height.mas_equalTo(50); &#125;]; [self.startBtn mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(self.bottomImageView.mas_leading).offset(5); make.bottom.equalTo(self.bottomImageView.mas_bottom).offset(-5); make.width.height.mas_equalTo(30); &#125;]; [self.fullScreenBtn mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.height.mas_equalTo(30); make.trailing.equalTo(self.bottomImageView.mas_trailing).offset(-5); make.centerY.equalTo(self.startBtn.mas_centerY); &#125;]; [self.currentTimeLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(self.startBtn.mas_trailing).offset(-3); make.centerY.equalTo(self.startBtn.mas_centerY); make.width.mas_equalTo(43); &#125;]; [self.totalTimeLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.trailing.equalTo(self.fullScreenBtn.mas_leading).offset(3); make.centerY.equalTo(self.startBtn.mas_centerY); make.width.mas_equalTo(43); &#125;]; [self.progressView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(self.currentTimeLabel.mas_trailing).offset(4); make.trailing.equalTo(self.totalTimeLabel.mas_leading).offset(-4); make.centerY.equalTo(self.startBtn.mas_centerY); &#125;]; [self.videoSlider mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(self.currentTimeLabel.mas_trailing).offset(4); make.trailing.equalTo(self.totalTimeLabel.mas_leading).offset(-4); make.centerY.equalTo(self.currentTimeLabel.mas_centerY).offset(-1); make.height.mas_equalTo(30); &#125;]; [self.progressIndicatorLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.width.mas_equalTo(160); make.height.mas_equalTo(40); make.center.equalTo(self); &#125;]; [self.activity mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self); &#125;]; [self.repeatBtn mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self); &#125;];&#125; 当然还需要对外暴漏我们的控制器试图的隐藏及显示，及一些子试图初始某些属性设置方法： 123456789101112131415161718192021222324252627282930313233/** * 显示控制器 */- (void)showControlView&#123; self.topImageView.alpha = 1; self.bottomImageView.alpha = 1; self.backBtn.alpha = 1;&#125;/** * 隐藏控制器 */- (void)hideControlView&#123; self.topImageView.alpha = 0; self.bottomImageView.alpha = 0; self.backBtn.alpha = 0;&#125;/** * 重置ControlView */- (void)resetControlView&#123; self.videoSlider.value = 0; self.progressView.progress = 0; self.currentTimeLabel.text = @"00:00"; self.totalTimeLabel.text = @"00:00"; self.progressIndicatorLabel.hidden = YES; self.repeatBtn.hidden = YES; self.backgroundColor = [UIColor clearColor];&#125; 封装 AVPlayer以上已经自定义好了我们的控制器试图，下面我们开始封装 AVPlayer。 首先我们需要对 AVPlayerItem 设置监听，监听我们的视频资源的状态，这里通过 KVO 监听播放器的状态： 12345678910//视频添加kvo监听[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(moviePlayDidEnd:) name:AVPlayerItemDidPlayToEndTimeNotification object:self.playerItem];// 视频资源的加载状态[self.playerItem addObserver:self forKeyPath:@"status" options:NSKeyValueObservingOptionNew context:nil];// 获取缓冲区[self.playerItem addObserver:self forKeyPath:@"loadedTimeRanges" options:NSKeyValueObservingOptionNew context:nil];// 缓冲区空了，需要等待数据[self.playerItem addObserver:self forKeyPath:@"playbackBufferEmpty" options:NSKeyValueObservingOptionNew context:nil];// 缓冲区有足够数据可以播放了[self.playerItem addObserver:self forKeyPath:@"playbackLikelyToKeepUp" options:NSKeyValueObservingOptionNew context:nil]; 然后在下面的回调方法中分别针对不同的状态进行不同的逻辑判断，主要为视频成功加载后需要为我们的播放器添加触摸手势，这里不建议直接重写 touches 的四个回调事件，因为这样会更新我们触摸逻辑的复杂度，其次视频如果加载失败，还需要额外的判断，不划算。所以这里建议直接使用手势，滑动事件监听手势的回调方法就可以了。 1- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context； 关于计算缓冲进度： 123456789- (NSTimeInterval)availableDuration&#123; NSArray *loadedTimeRanges = [[_player currentItem] loadedTimeRanges]; CMTimeRange timeRange = [loadedTimeRanges.firstObject CMTimeRangeValue];// 获取缓冲区域 float startSeconds = CMTimeGetSeconds(timeRange.start); float durationSeconds = CMTimeGetSeconds(timeRange.duration); NSTimeInterval result = startSeconds + durationSeconds;// 计算缓冲总进度 return result;&#125; loadedTimeRanges 这个属性是一个数组，里面装的是本次缓冲的时间范围，这个用一个结构体 CMTimeRange 表示，start 表示本次缓冲时间的起点，duratin 表示本次缓冲持续的时间范围。 关于 CMTime,我们可以通过 CMTimeGetSeconds([_player currentTime]) 获取当前播放器的时间，但是通常我们可能需要换算为小时:分钟:秒这种格式。 关于触摸的回调事件，主要为控制左右滑动时视频的快进快退逻辑，及上下滑动时的音量控制逻辑，具体可参考代码： 123456/** * pan手势事件 * * @param pan UIPanGestureRecognizer */- (void)panDirection:(UIPanGestureRecognizer *)pan 还有一个很重要的触摸事件，就是滑动我们的进度条 UISlider 的回调，这个回调里面主要为处理 NSTimer 及滑动过程中进度指示 Label 的文本内容设置： 123456789101112131415161718/** * slider开始滑动事件 * * @param slider UISlider */- (void)progressSliderTouchBegan:(UISlider *)slider; /** * slider滑动中事件 * * @param slider UISlider */- (void)progressSliderValueChanged:(UISlider *)slider/** * slider结束滑动事件 * * @param slider UISlider */- (void)progressSliderTouchEnded:(UISlider *)slider; 最后就是关于视频播放完成后，我们需要对播放器及播放器控制器进行重置： 123456789101112131415/** * 播放完了 * * @param notification 通知 */- (void)moviePlayDidEnd:(NSNotification *)notification&#123; self.state = BHPlayerStateStopped; self.playDidEnd = YES; self.controlView.repeatBtn.hidden = NO; // 初始化显示controlView为YES self.isMaskShowing = NO; // 延迟隐藏controlView [self animateShow];&#125; 在这里提醒一点很重要的地方，当我们的时候及处于静音的时候需要做以下处理： 1234// 使用这个category的应用不会随着手机静音键打开而静音，可在手机静音下播放声音 NSError *setCategoryError = nil; BOOL success = [[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback error: &amp;setCategoryError]; if (!success) &#123; /* handle the error in setCategoryError */ &#125; 代码可以下载GITHUB中BlogDemo进行查看。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式创建 UILabel 和 UIButton]]></title>
    <url>%2F2015%2F08%2F05%2F%E9%93%BE%E5%BC%8F%E5%88%9B%E5%BB%BAUILabel%E5%92%8CUIButton%2F</url>
    <content type="text"><![CDATA[其实最早接触链式编程是使用 Masonry 框架的时候，对于之前大部分写集中式编码的人而言会觉得眼前一亮，当所有的操作通过点号(.)符号链接起来时候之后，代码的可读性大大的增强了。所以在之前就使用这种方式对 AFNetworking 进行了二次封装，链接地址。 为什么想到把 UILabel/UIButton 也使用这种方式其实之前在项目开发中会在多个地方用到手动创建添加 UILabel/UIButton 的视图，写了多了就将其封装在了一个 tools 文件内了，一直觉得并不是很好，因为这种方式一旦有某一个地方对 UILable/UIButton 有针对性的属性修改时，一种解决方式是当真正获取到 View 时再修改，另一种方式就是在原有的方法上添加参数进行修改，这样就很不灵活，而且需要给默认参数使用 nil 进行占位，代码看起来就很丑陋；而使用链式编程恰恰可以解决这个问题，另外使用 Category 的方式也不会浸入项目原有代码。 UILable 式例其实我们通常创建一个 UILable 时常用的属性会有 text/textColor/font/textAlignment，这里我主要封装的也是这几个属性，其实可以根据项目动态的进行添加其他属性。 #import "UILabel+BHLabel.h" @implementation UILabel (BHLabel) /** * 文本内容 */ -(UILabel *(^)(NSString *text))bh_text { return ^UILabel *(NSString *text) { self.text = text; return self; }; } /** * 文本颜色 */ -(UILabel *(^)(UIColor *color))bh_textColor { return ^UILabel *(UIColor *color) { self.textColor = color; return self; }; } /** * 文本字体大小 */ -(UILabel *(^)(CGFloat fontSize))bh_textFont { return ^UILabel *(CGFloat fontSize) { self.font = [UIFont systemFontOfSize:fontSize]; return self; }; } /** * 文本居中方式 */ -(UILabel *(^)(NSTextAlignment textAlignment))bh_textAlignment { return ^UILabel *(NSTextAlignment textAlignment) { self.textAlignment = textAlignment; return self; }; } @end 最后关于链式编程的一些理解链式编程的代码结构上，通常我们的方法返回结果会是 void/NSString */NSInteger….这种空值或者指针对象，但是链式编程里所有的函数方法返回的都是一个 block，当这个 block 真正执行完成后将把对象自身返回进行下一步操作。我觉得链式编程从某种角度讲大大提高了代码的可读性，这样后期代码就减少了维护成本，而在学习 ReactiveCocoa 时也是使用了这种函数式编程思想。代码可以下载GITHUB中 BlogDemo进行查看。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIBezierPath 配合 CAShapeLayer 画一些有趣的图形]]></title>
    <url>%2F2015%2F05%2F17%2FUIBezierPath%E9%85%8D%E5%90%88CAShapeLayer%E7%94%BB%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[CAShapeLayer是CALayer的子类，但是比CALayer更灵活，配合一个神奇的属性path用这个属性配合上 UIBezierPath 这个类就可以达到超神的效果。 玩一下 UIBezierPathUIBezierPath 顾名思义，这是用贝塞尔曲线的方式来构建一段弧线，你可以用任意条弧线来组成你想要的形状，它包含起始点、终点、及控制点三个参数。如下图红色矩形范围内的白色背景，最上面就是一条有弧度的曲线。 它可以用 CAShapeLayer+UIBezierPath 来做，思路大概是这样，先移动到左上方的位置，然后向下划线，然后往右划线，然后往上划线，还剩一个盖子，这个盖子就用一个控制点控制曲率，非常简单，图中的红色点即为控制点，代码如下： 12345678910111213141516-(void)initLayer&#123; CAShapeLayer *layer = [[CAShapeLayer alloc] init]; UIBezierPath *path = [[UIBezierPath alloc] init]; [path moveToPoint:CGPointMake(0, SCREEN_HEIGHT - MENU_HEIGHT)]; [path addLineToPoint:CGPointMake(0, SCREEN_HEIGHT)]; [path addLineToPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT)]; [path addLineToPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT - MENU_HEIGHT)]; [path addQuadCurveToPoint:CGPointMake(0, SCREEN_HEIGHT - MENU_HEIGHT) controlPoint:CGPointMake(SCREEN_WIDTH/2.f, SCREEN_HEIGHT - MENU_HEIGHT * 2.0f)]; layer.path = path.CGPath; //设置填充色及画笔颜色 layer.fillColor = [UIColor purpleColor].CGColor; layer.strokeColor = [UIColor blueColor].CGColor; layer.lineWidth = 1.f; [self.view.layer addSublayer:layer];&#125; 效果如图： 使用 UIBezierPath 画圆及添加加载动画123456789101112131415161718192021-(void)initCircle&#123; CAShapeLayer *layer = [[CAShapeLayer alloc] init]; UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 200, 200)]; layer.path = path.CGPath; layer.fillColor = [UIColor clearColor].CGColor; layer.strokeColor = [UIColor blueColor].CGColor; layer.lineWidth = 1.f; //设置stroke起始点 layer.strokeStart = 0; layer.strokeEnd = 0.75; layer.frame = CGRectMake(0, 0, 200, 200); layer.position = self.view.center; [self.view.layer addSublayer:layer]; //动画显示了从1到0之间每一个值对这条曲线的影响 CABasicAnimation *animation = [[CABasicAnimation alloc] init]; animation.fromValue = [NSNumber numberWithFloat:1.0]; animation.toValue = [NSNumber numberWithFloat:0.0]; animation.duration = 5.f; [layer addAnimation:animation forKey:@"strokeStart"];&#125; 利用 layer 的 mask 属性为图片添加遮罩12345678910111213141516171819202122-(void)showImage&#123; UIImage *image = BHIMG(@"sunyizhen.jpg"); UIImageView *imageView = [[UIImageView alloc] initWithImage:image]; imageView.contentMode = UIViewContentModeCenter; imageView.mj_y = kNavBarHeight; [self.view addSubview:imageView]; UIBezierPath *originPath = [UIBezierPath bezierPathWithRect:CGRectInset(imageView.bounds, 67.f, 91.5f)]; UIBezierPath *finalPath = [UIBezierPath bezierPathWithRect:imageView.bounds]; CAShapeLayer *layer = [CAShapeLayer layer]; layer.path = finalPath.CGPath; // layer.fillColor = [UIColor clearColor].CGColor; // layer.strokeColor = [UIColor blueColor].CGColor; // layer.lineWidth = 2.f; imageView.layer.mask = layer; CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"path"]; animation.fromValue = (__bridge id _Nullable)(originPath.CGPath); animation.toValue = (__bridge id _Nullable)(finalPath.CGPath); animation.duration = 2.f; [layer addAnimation:animation forKey:@"path"];&#125; 效果如下 最后总之使用 UIbezierPath 和 CAShapeLayer 可以画出你想要的任何形状，没有它做不到，只有你想不到，当然有时候可能会比较复杂而显得比较笨拙，但最终实现后确实会显得很有趣。 代码可以下载GITHUB中BlogDemo进行查看。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为 AFNetWorking 添加接口数据缓存]]></title>
    <url>%2F2015%2F04%2F12%2F%E4%B8%BAAFNetWorking%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[NSURLSession 是iOS7之后对 NSURLConnection 更进一步的优化封装，可通过 NSURLSessionConfiguration 对其进行初始化设置，其中 requestCachePolicy 属性设置就是配置获取得到 NSURLResponse 之后的缓存策略： 12345678910111213141516typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; // NSURLRequest默认的cache policy，使用Protocol协议定义 NSURLRequestUseProtocolCachePolicy = 0, NSURLRequestReloadIgnoringLocalCacheData = 1, // 忽略缓存直接从原始地址下载 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, // 只有在cache中不存在data时才从原始地址下载 NSURLRequestReturnCacheDataElseLoad = 2, // 只使用cache数据，如果不存在cache，请求失败;用于没有建立网络连接离线模式 NSURLRequestReturnCacheDataDontLoad = 3, // 忽略本地和远程的缓存数据，直接从原始地址下载，与NSURLRequestReloadIgnoringCacheData类似，苹果未实现。 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented // 验证本地数据与远程数据是否相同，如果不同则下载远程数据，否则使用本地数据，苹果未实现 NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;; 关于 AFNetWorking 的缓存其实 AFNetWorking(特指3.x版本)本质上讲就是基于对 NSURLSession 的再一次封装，所以它默认就已经可以使用 NSURLCache 缓存，即我们可以直接使用 NSURLCache 进行缓存设置，而 NSURLCache 是一个 NSURLRequest 对应一个 NSURLResponse 进行缓存的。 1- (nullable NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request; 我们正常的使用 AFN 进行 get 请求如下： 1234567AFHTTPSessionManager *manager = [self setupAFHTTPSessionManager]; // 此处实际上会对AFHTTPSessionManager进行一些初始化设置 NSURLSessionDataTask *task = [manager GET:self.requestUrl parameters:self.parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123; handler(responseObject, nil); &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123; handler(nil, error); &#125;]; 然后 get 方法创建完成后会返回一个 NSURLSessionDataTask 对象，我们通过 task.originalRequest 即可获取上一次的 NSURLRequest 对象，通过它我们即可以从 cache 中获取缓存数据。 123456NSCachedURLResponse *reaponse = [[NSURLCache sharedURLCache] cachedResponseForRequest:a.originalRequest];if (reaponse)&#123; handler(reaponse.data, nil); [task cancel];&#125; 但是我们在第一进行请求的时候肯定是没有缓存的，所以在第一次缓存成功后需要对返回的 NSURLResponse 对象进行缓存： 123 NSData *data = [NSJSONSerialization dataWithJSONObject:responseObject options:0 error:nil];NSCachedURLResponse * cachedResponse = [[NSCachedURLResponse alloc] initWithResponse:task.response data:data];[[NSURLCache sharedURLCache] storeCachedResponse:cachedResponse forRequest:task.originalRequest]; 封装我们自己的 NSCache主要最对缓存数据进行过期处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface BHCustomURLCache : NSURLCache+ (instancetype)standardURLCache;@end#import "BHCustomURLCache.h"static NSString * const CustomURLCacheExpirationKey = @"CustomURLCacheExpiration";static NSTimeInterval const CustomURLCacheExpirationInterval = 600;@interface BHCustomURLCache()@end@implementation BHCustomURLCache+ (instancetype)standardURLCache &#123; static BHCustomURLCache *_standardURLCache = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _standardURLCache = [[BHCustomURLCache alloc] initWithMemoryCapacity:(2 * 1024 * 1024) diskCapacity:(100 * 1024 * 1024) diskPath:nil]; &#125;); return _standardURLCache;&#125; #pragma mark - NSURLCache - (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request&#123; NSCachedURLResponse *cachedResponse = [super cachedResponseForRequest:request]; if (cachedResponse) &#123; NSDate* cacheDate = cachedResponse.userInfo[CustomURLCacheExpirationKey]; NSDate* cacheExpirationDate = [cacheDate dateByAddingTimeInterval:CustomURLCacheExpirationInterval]; if ([cacheExpirationDate compare:[NSDate date]] == NSOrderedAscending) &#123; [self removeCachedResponseForRequest:request]; return nil; &#125; &#125; return cachedResponse;&#125;- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request&#123; NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithDictionary:cachedResponse.userInfo]; userInfo[CustomURLCacheExpirationKey] = [NSDate date]; NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:cachedResponse.response data:cachedResponse.data userInfo:userInfo storagePolicy:cachedResponse.storagePolicy]; [super storeCachedResponse:modifiedCachedResponse forRequest:request];&#125;@end 最后关于实际开发中，接口数据可能需要实时获取最新的数据，这就要需要我们自己修改接口数据刷新策略，一种常见的做法，每次接口请求的时候都带上上次请求的时间戳，当服务端有新数据返回时即解析最新的数据，重新加入缓存；当没有新数据时则可以通过返回状态码302的方式通知客户端直接获取缓存数据。 代码可以下载GITHUB中BlogDemo进行查看。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对 AFNetworking 的链式二次封装]]></title>
    <url>%2F2015%2F04%2F10%2F%E5%AF%B9AFNetworking%E7%9A%84%E9%93%BE%E5%BC%8F%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[之前在使用 AFNetworking都会进行二次封装便于开发使用，但是通常的结构是一种集中式的封装，如下： 123- (void)asyncWithQueryString:(NSString *)query params:(NSDictionary *)params requestType:(RequestType)requestType completionHandler:(void (^)(NSDictionary *result, NSError *error))handler； 这种结构的弊端在于，每次调用的时候都需要传递所有的参数，而即使没有参数也需要传递 nil 值站位，尤其如果一开始没有封装好导致后期要在方法里面添加一个参数，那么我们所有调用此方法的地方都需要进行修改，虽然这种可能性很小。所以后来采用了链式结构进行了封装。使用这种方法主要是借鉴了IOS中的布局适配框架 Masonry，关于链式编程更多的了解可以参考： https://github.com/Wzxhaha/WZXProgrammingIdeas http://www.ithao123.cn/content-1780874.html 链式结构的最终调用式例123456[[BHNetReqManager sharedManager].bh_requestUrl(@"http://binhandev.github.io/").bh_requestType(GET).bh_responseSerializer(HTTPResponseSerializer).bh_parameters(nil) startRequestWithCompleteHandler:^(id response, NSError *error) &#123;&#125; 如果我们想添加方法设置新的成员变量，则直接在后面添加方法，如： 1234567- (BHNetReqManager* (^)(id parameter))bh_newmothed&#123; return ^BHNetReqManager* (id parameter) &#123; self.newvar = var; return self; &#125;;&#125; 而调用此方法则直接 .bh_newmothed() 即可 1234[[BHNetReqManager sharedManager].bh_requestUrl(@"http://binhandev.github.io/").bh_newmothed() startRequestWithCompleteHandler:^(id response, NSError *error) &#123;&#125; 代码可以下载GITHUB中 BlogDemo 进行查看。]]></content>
      <tags>
        <tag>移动开发</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个有爱的404页面]]></title>
    <url>%2F2015%2F02%2F17%2F%E4%B8%80%E4%B8%AA%E6%9C%89%E7%88%B1%E7%9A%84404%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[在支付宝的爱心支付和恩基爱看到一些捐助活动偶尔也会献些爱心，当看到腾讯的这个公益 404 页面真是喜欢的不得了，更重要的在 hexo 中接入也很简单，当然从某种意义上并不希望经常看到它。 在项目根目录source文件夹下直接创建404.html页面 编辑下面html代码，如果定制超链接，修改“homePageUrl”、“homePageName”两个参数即可。 一定要设置layout:false(还有三个短横线)，不然会被hexo解析。 123456789101112layout: false---&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;宝贝，公益404带你们回家&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="http://yoursite.com/yourPage.html" homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果展示]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
